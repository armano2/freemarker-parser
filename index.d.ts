// Generated by dts-bundle v0.7.3

declare module 'freemarker-parser' {
    import { Parser } from 'freemarker-parser/Parser';
    export { Parser };
}

declare module 'freemarker-parser/Parser' {
    import { IToken } from 'freemarker-parser/types/Tokens';
    import { IProgram } from 'freemarker-parser/types/Node';
    export interface IParserReturn {
        ast: IProgram;
        tokens: IToken[];
    }
    export class Parser {
        parse(template: string): IParserReturn;
    }
}

declare module 'freemarker-parser/types/Tokens' {
    import { ENodeType } from 'freemarker-parser/Symbols';
    import { IParams, NodeNames } from 'freemarker-parser/types/Node';
    export interface IDirectivesTypes {
        [n: string]: NodeNames;
    }
    export const directives: IDirectivesTypes;
    export interface IToken {
        type: ENodeType;
        start: number;
        end: number;
        params: IParams;
        text: string;
        isClose: boolean;
    }
}

declare module 'freemarker-parser/types/Node' {
    import { IExpression } from 'freemarker-parser/params/Types';
    export enum NodeNames {
        Program = "Program",
        Else = "Else",
        Condition = "Condition",
        Include = "Include",
        List = "List",
        Text = "Text",
        Assign = "Assign",
        Global = "Global",
        Local = "Local",
        Macro = "Macro",
        MacroCall = "MacroCall",
        Interpolation = "Interpolation",
        Attempt = "Attempt",
        Recover = "Recover",
        Comment = "Comment",
        Switch = "Switch",
        SwitchCase = "SwitchCase",
        SwitchDefault = "SwitchDefault",
        Break = "Break",
        ConditionElse = "ConditionElse",
    }
    export interface IParams extends Array<IExpression> {
        [i: number]: IExpression;
    }
    export interface INode {
        type: NodeNames;
        start: number;
        end: number;
    }
    export interface IProgram extends INode {
        type: NodeNames.Program;
        body: INode[];
    }
    export interface ICondition extends INode {
        type: NodeNames.Condition;
        params: IParams;
        consequent: INode[];
        alternate?: INode[];
    }
    export interface IInclude extends INode {
        type: NodeNames.Include;
        params: IParams;
    }
    export interface IList extends INode {
        type: NodeNames.List;
        params: IParams;
        body: INode[];
        fallback?: INode[];
    }
    export interface IText extends INode {
        type: NodeNames.Text;
        text: string;
    }
    export interface IMacro extends INode {
        type: NodeNames.Macro;
        params: IParams;
        body: INode[];
    }
    export interface IMacroCall extends INode {
        type: NodeNames.MacroCall;
        params: IParams;
        name: string;
        body?: INode[];
    }
    export interface IAssign extends INode {
        type: NodeNames.Assign;
        params: IParams;
    }
    export interface IGlobal extends INode {
        type: NodeNames.Global;
        params: IParams;
    }
    export interface ILocal extends INode {
        type: NodeNames.Local;
        params: IParams;
    }
    export interface IInterpolation extends INode {
        type: NodeNames.Interpolation;
        params: IParams;
    }
    export interface IAttempt extends INode {
        type: NodeNames.Attempt;
        body: INode[];
        fallback?: INode[];
    }
    export interface IComment extends INode {
        type: NodeNames.Comment;
        text: string;
    }
    export interface ISwitch extends INode {
        type: NodeNames.Switch;
        params: IParams;
        cases: INode[];
    }
    export interface ISwitchCase extends INode {
        type: NodeNames.SwitchCase;
        params: IParams;
        consequent: INode[];
    }
    export interface ISwitchDefault extends INode {
        type: NodeNames.SwitchDefault;
        consequent: INode[];
    }
    export interface IBreak extends INode {
        type: NodeNames.Break;
    }
    export type AllNodeTypes = IInterpolation | IMacroCall | IProgram | IText | IComment | ICondition | IList | IGlobal | ILocal | IAssign | IInclude | IMacro | IAttempt | ISwitch | ISwitchCase | ISwitchDefault | IBreak;
}

declare module 'freemarker-parser/Symbols' {
    export enum ENodeType {
        Program = "Program",
        Directive = "Directive",
        Macro = "Macro",
        Text = "Text",
        Interpolation = "Interpolation",
        Comment = "Comment",
    }
    export interface ISymbol {
        startToken: string;
        endToken: string[];
        type: ENodeType;
        end: boolean;
    }
    export const symbols: ISymbol[];
    export const whitespaces: string[];
    export function isWhitespace(char: string): boolean;
}

declare module 'freemarker-parser/params/Types' {
    export interface IExpression {
        type: string;
    }
    export interface ILiteral extends IExpression {
        type: 'Literal';
        value: any;
        raw: string;
    }
    export interface IArrayExpression extends IExpression {
        type: 'ArrayExpression';
        elements: IExpression[];
    }
    export interface IIdentifier extends IExpression {
        type: 'Identifier';
        name: string;
    }
    export interface IBinaryExpression extends IExpression {
        type: 'BinaryExpression';
        operator: string;
        left: IExpression;
        right: IExpression;
    }
    export interface ILogicalExpression extends IExpression {
        type: 'LogicalExpression';
        operator: string;
        left: IExpression;
        right: IExpression;
    }
    export interface IUnaryExpression extends IExpression {
        type: 'UnaryExpression';
        operator: string;
        argument: IExpression;
        prefix: boolean;
    }
    export interface IMemberExpression extends IExpression {
        type: 'MemberExpression';
        computed: boolean;
        object: IExpression;
        property: IExpression | null;
    }
    export interface ICallExpression extends IExpression {
        type: 'ConditionalExpression';
        arguments: IExpression;
        callee: IExpression;
    }
    export interface IUnaryOperators {
        [n: string]: boolean;
    }
    export interface IBinaryOperators {
        [n: string]: number;
    }
    export interface ILiteralOperators {
        [n: string]: true | false | null;
    }
}

