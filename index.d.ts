// Generated by dts-bundle v0.7.3

declare module 'freemarkerjs' {
    import { Parser } from 'freemarkerjs/Parser';
    export { Parser };
}

declare module 'freemarkerjs/Parser' {
    import Program from 'freemarkerjs/nodes/Program';
    export class Parser {
        template: string;
        constructor();
        parse(template: string): Program;
    }
}

declare module 'freemarkerjs/nodes/Program' {
    import { BaseNode } from 'freemarkerjs/nodes/BaseNode';
    export default class Program extends BaseNode {
        children: BaseNode[];
        constructor(start: number, end: number);
        addChild(node: BaseNode): BaseNode;
    }
}

declare module 'freemarkerjs/nodes/BaseNode' {
    import { INodeConfig } from 'freemarkerjs/NodeConfig';
    import { ENodeType, EType } from 'freemarkerjs/Types';
    export class BaseNode {
        type: string;
        $nodeType: ENodeType;
        $eType: string;
        start: number;
        end: number;
        $config: INodeConfig;
        constructor(nodeType: string, start: number, end: number, eType: EType);
        canAddTo(node: BaseNode): boolean;
        addChild(node: BaseNode): BaseNode;
    }
}

declare module 'freemarkerjs/NodeConfig' {
    import { EType } from 'freemarkerjs/Types';
    export interface INodeConfig {
        isSelfClosing: boolean;
        onlyIn?: EType[];
        disallowParams?: boolean;
    }
    export interface INodeConfigObj {
        [c: string]: INodeConfig;
    }
    export const NodeConfig: INodeConfigObj;
}

declare module 'freemarkerjs/Types' {
    import { IExpression } from 'freemarkerjs/params/Types';
    export enum ENodeType {
        Program = "Program",
        Directive = "Directive",
        Macro = "Macro",
        Text = "Text",
        Interpolation = "Interpolation",
    }
    export enum EType {
        Program = "@program",
        Text = "@text",
        MacroCall = "@macro",
        Interpolation = "@interpolation",
        if = "if",
        else = "else",
        elseif = "elseif",
        list = "list",
        include = "include",
        assign = "assign",
        attempt = "attempt",
        compress = "compress",
        escape = "escape",
        noescape = "noescape",
        fallback = "fallback",
        function = "function",
        flush = "flush",
        global = "global",
        import = "import",
        local = "local",
        lt = "lt",
        macro = "macro",
        nested = "nested",
        nt = "nt",
        recover = "recover",
        recurse = "recurse",
        return = "return",
        rt = "rt",
        setting = "setting",
        stop = "stop",
        switch = "switch",
        case = "case",
        break = "break",
        t = "t",
        visit = "visit",
    }
    export interface IParams extends Array<IExpression> {
        [i: number]: IExpression;
    }
}

declare module 'freemarkerjs/params/Types' {
    export interface IExpression {
        type: string;
    }
    export interface ILiteral extends IExpression {
        type: 'Literal';
        value: any;
        raw: string;
    }
    export interface IArrayExpression extends IExpression {
        elements: IExpression[];
    }
    export interface IIdentifier extends IExpression {
        type: 'Identifier';
        name: string;
    }
    export interface IBinaryExpression extends IExpression {
        type: 'BinaryExpression';
        operator: string;
        left: IExpression;
        right: IExpression;
    }
    export interface ILogicalExpression extends IExpression {
        type: 'LogicalExpression';
        operator: string;
        left: IExpression;
        right: IExpression;
    }
    export interface IUnaryExpression extends IExpression {
        type: 'UnaryExpression';
        operator: string;
        argument: IExpression;
        prefix: boolean;
    }
    export interface IMemberExpression extends IExpression {
        type: 'MemberExpression';
        computed: boolean;
        object: IExpression;
        property: IExpression | null;
    }
    export interface ICallExpression extends IExpression {
        type: 'ConditionalExpression';
        arguments: IExpression;
        callee: IExpression;
    }
}

