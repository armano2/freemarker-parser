{"version":3,"file":"index.js","sources":["src/errors/NodeError.ts","src/errors/ParamError.ts","src/Symbols.ts","src/utils/Chars.ts","src/types/Params.ts","src/ParamsParser.ts","src/utils/Params.ts","src/Tokenizer.ts","src/types/Node.ts","src/utils/Node.ts","src/types/Tokens.ts","src/utils/Token.ts","src/Parser.ts"],"sourcesContent":["import { AllNodeTypes } from '../types/Node'\nimport { IToken } from '../types/Tokens'\n\nexport default class NodeError extends Error {\n  public nodeType : string\n  public start : number\n  public end : number\n\n  constructor (m : string, el : AllNodeTypes | IToken | undefined) {\n    super(m)\n    if (el) {\n      this.nodeType = el.type\n      this.start = el.start\n      this.end = el.end\n    }\n    // Set the prototype explicitly.\n    Object.setPrototypeOf(this, NodeError.prototype)\n  }\n}\n","export default class ParamError extends SyntaxError {\n  public index : number\n  public description : string\n\n  constructor (message : string, index : number) {\n    super(`${message} at character ${index}`)\n    this.description = message\n    this.index = index\n\n    // Set the prototype explicitly.\n    Object.setPrototypeOf(this, ParamError.prototype)\n  }\n}\n","export enum ENodeType {\n  Program = 'Program',\n  Directive = 'Directive',\n  Macro = 'Macro',\n  Text = 'Text',\n  Interpolation = 'Interpolation',\n  Comment = 'Comment',\n}\n\nexport interface ISymbol {\n  startToken : string\n  endToken : string[]\n  type : ENodeType\n  end : boolean\n}\n\nexport const symbols : ISymbol[] = [\n  { startToken: '<#--', endToken: ['-->'], type: ENodeType.Comment, end: false },\n  { startToken: '</#', endToken: ['>', '/>'], type: ENodeType.Directive, end: true },\n  { startToken: '<#', endToken: ['>', '/>'], type: ENodeType.Directive, end: false },\n  { startToken: '</@', endToken: ['>', '/>'], type: ENodeType.Macro, end: true },\n  { startToken: '<@', endToken: ['>', '/>'], type: ENodeType.Macro, end: false },\n  // tslint:disable-next-line:no-invalid-template-strings\n  { startToken: '${', endToken: ['}'], type: ENodeType.Interpolation, end: false },\n]\n","export interface IBinaryOperators {\n  [n : string] : number\n}\n\nexport interface IUnaryOperators {\n  [n : string] : boolean\n}\n\nexport interface ILiteralOperators {\n  [n : string] : true | false | null\n}\n\nexport enum ECharCodes {\n  TAB = 9, // (tab)\n  LINE_FEED = 10, // \\n\n  CARRIAGE_RETURN = 13, // \\r\n  SPACE = 32, // (space)\n  HASH = 35, // #\n  DOLAR = 36, // $\n  PERIOD_CODE = 46, // '.'\n  SLASH = 47, // /\n  COMMA_CODE = 44, // ','\n  HYPHEN = 45, // -\n  SQUOTE_CODE = 39, // single quote\n  DQUOTE_CODE = 34, // double quotes\n  OPAREN_CODE = 40, // (\n  CPAREN_CODE = 41, // )\n  OBRACK_CODE = 91, // [\n  CBRACK_CODE = 93, // ]\n  SEMCOL_CODE = 59, // ;\n  LESS_THAN = 60, // <\n  GREATER_THAN = 62, // >\n  AT_SYMBOL = 64, // @\n  OBRACE_CODE = 123, // {\n  CBRACE_CODE = 125, // }\n}\n\n// see [Order of operations](http://en.wikipedia.org/wiki/Order_of_operations#Programming_language)\nexport const binaryOps : IBinaryOperators = {\n  '||': 1,\n  '&&': 2,\n  '^': 4,\n  '&': 5,\n  '==': 6, '!=': 6, '===': 6, '!==': 6,\n  '<': 7, '>': 7, '<=': 7, '>=': 7, 'gt': 7, 'lt': 7, 'gte': 7, 'lte': 7,\n  '+': 9, '-': 9,\n  '*': 10, '/': 10, '%': 10,\n}\n\nexport function isDecimalDigit (ch : number) : boolean {\n  return ch >= 48 && ch <= 57 // 0...9\n}\n\nexport function isLetter (ch : number) : boolean {\n  return (ch >= 65 && ch <= 90) || // a...z\n  (ch >= 97 && ch <= 122) // A...Z\n}\n\nexport function isWhitespace (ch : number) : boolean {\n  return ch === ECharCodes.SPACE || ch === ECharCodes.TAB || ch === ECharCodes.CARRIAGE_RETURN || ch === ECharCodes.LINE_FEED\n}\n\n// any non-ASCII that is not an operator\nexport function isIdentifierStart (ch : number) : boolean {\n  return (\n    isLetter(ch) ||\n    (ch === 36) || (ch === 95) || // `$` and `_`\n    ch >= 128\n  ) && !binaryOps[String.fromCharCode(ch)]\n}\n\n// any non-ASCII that is not an operator\nexport function isIdentifierPart (ch : number) : boolean {\n  return (\n    isLetter(ch) ||\n    isDecimalDigit(ch) ||\n    (ch === 36) || (ch === 95) || // `$` and `_`\n    ch >= 128\n  ) && !binaryOps[String.fromCharCode(ch)]\n}\n\n// Use a quickly-accessible map to store all of the unary operators\nexport const unaryOps : IUnaryOperators = {\n  '-': true,\n  '!': true,\n  '~': true,\n  '+': true,\n  '?': true,\n  '=': true,\n  '+=': true,\n  '-=': true,\n  '*=': true,\n  '/=': true,\n  '%=': true,\n  '--': true,\n  '++': true,\n}\n\n// Get return the longest key length of any object\nfunction getMaxKeyLen (obj : object) : number {\n  let maxLen = 0\n  let len\n  for (const key of Object.keys(obj)) {\n    len = key.length\n    if (len > maxLen) {\n      maxLen = len\n    }\n  }\n  return maxLen\n}\n\nexport const maxUnopLen = getMaxKeyLen(unaryOps)\nexport const maxBinopLen = getMaxKeyLen(binaryOps)\n\n// Store the values to return for the various literals we may encounter\nexport const literals : ILiteralOperators = {\n  true: true,\n  false: false,\n  null: null,\n}\n","export enum ParamNames {\n  Empty = 'Empty',\n  Compound = 'Compound',\n  Identifier = 'Identifier',\n  MemberExpression = 'MemberExpression',\n  Literal = 'Literal',\n  CallExpression = 'CallExpression',\n  UnaryExpression = 'UnaryExpression',\n  BinaryExpression = 'BinaryExpression',\n  LogicalExpression = 'LogicalExpression',\n  ArrayExpression = 'ArrayExpression',\n}\n\nexport interface IExpression {\n  type : ParamNames\n}\n\nexport interface IEmpty extends IExpression {\n  type : ParamNames.Empty\n}\n\nexport interface ICompound extends IExpression {\n  type : ParamNames.Compound\n  body : AllParamTypes[]\n}\n\nexport interface ILiteral extends IExpression {\n  type : ParamNames.Literal\n  value : any\n  raw : string\n}\n\nexport interface IArrayExpression extends IExpression {\n  type : ParamNames.ArrayExpression\n  elements : AllParamTypes[]\n}\n\nexport interface IIdentifier extends IExpression {\n  type : ParamNames.Identifier\n  name : string\n}\n\nexport interface IBinaryExpression extends IExpression {\n  type : ParamNames.BinaryExpression\n  operator : string\n  left : AllParamTypes\n  right : AllParamTypes\n}\n\nexport interface ILogicalExpression extends IExpression {\n  type : ParamNames.LogicalExpression\n  operator : string\n  left : AllParamTypes\n  right : AllParamTypes\n}\n\nexport interface IUnaryExpression extends IExpression {\n  type : ParamNames.UnaryExpression\n  operator : string\n  argument : AllParamTypes\n  prefix : boolean\n}\n\nexport interface IMemberExpression extends IExpression {\n  type : ParamNames.MemberExpression\n  computed : boolean\n  object : AllParamTypes\n  property : AllParamTypes | null\n}\n\nexport interface ICallExpression extends IExpression {\n  type : ParamNames.CallExpression\n  arguments : AllParamTypes[]\n  callee : AllParamTypes\n}\n\nexport type AllParamTypes = ILiteral | IArrayExpression | IIdentifier |\n  IBinaryExpression | ILogicalExpression | IUnaryExpression |\n  IMemberExpression | ICallExpression | ICompound\n","import ParamError from './errors/ParamError'\nimport {\n  AllParamTypes,\n  IArrayExpression,\n  IBinaryExpression,\n  ICallExpression,\n  IIdentifier,\n  ILiteral,\n  ILogicalExpression,\n  IMemberExpression,\n  IUnaryExpression,\n  ParamNames,\n} from './types/Params'\nimport {\n  binaryOps,\n  ECharCodes,\n  isDecimalDigit,\n  isIdentifierPart,\n  isIdentifierStart,\n  isWhitespace,\n  literals,\n  maxBinopLen,\n  maxUnopLen,\n  unaryOps,\n} from './utils/Chars'\n\n// Specify values directly\n// - Strings: \"Foo\" or 'Foo' or \"It's \\\"quoted\\\"\" or 'It\\'s \"quoted\"' or r\"C:\\raw\\string\"\n// - Numbers: 123.45\n// - Booleans: true, false\n// - Sequences: [\"foo\", \"bar\", 123.45];Ranges: 0..9, 0..<10 (or 0..!10), 0..\n// - Hashes: {\"name\":\"green mouse\", \"price\":150}\n// Retrieving variables\n// - Top-level variables: user\n// - Retrieving data from a hash: user.name, user[\"name\"]\n// - Retrieving data from a sequence: products[5]\n// - Special variable: .main\n// String operations\n// - Interpolation and concatenation: \"Hello ${user}!\" (or \"Hello \" + user + \"!\")\n// - Getting a character: name[0]\n// - String slice: Inclusive end: name[0..4], Exclusive end: name[0..<5], Length-based (lenient): name[0..*5], Remove starting: name[5..]\n// Sequence operations\n// - Concatenation: users + [\"guest\"]\n// - Sequence slice: Inclusive end: products[20..29], Exclusive end: products[20..<30], Length-based (lenient): products[20..*10], Remove starting: products[20..]\n// Hash operations\n// - Concatenation: passwords + { \"joe\": \"secret42\" }\n// - Arithmetical calculations: (x * 1.5 + 10) / 2 - y % 100\n// - Comparison: x == y, x != y, x < y, x > y, x >= y, x <= y, x lt y, x lte y, x gt y, x gte y, ...etc.\n// - Logical operations: !registered && (firstVisit || fromEurope)\n// - Built-ins: name?upper_case, path?ensure_starts_with('/')\n// - Method call: repeat(\"What\", 3)\n// Missing value handler operators:\n// - Default value: name!\"unknown\" or (user.name)!\"unknown\" or name! or (user.name)!\n// - Missing value test: name?? or (user.name)??\n// - Assignment operators: =, +=, -=, *=, /=, %=, ++, --\n\ninterface IBiopInfo {\n  value : string\n  prec : number\n}\n\nfunction isIBiopInfo (object : any) : object is IBiopInfo {\n  return object && 'prec' in object\n}\n\nfunction isAllParamTypes (object : any) : object is AllParamTypes {\n  return object && 'type' in object\n}\n\n// Returns the precedence of a binary operator or `0` if it isn't a binary operator\nconst binaryPrecedence = (opVal : string) : number => binaryOps[opVal] || 0\n\n// Utility function (gets called from multiple places)\n// Also note that `a && b` and `a || b` are *logical* expressions, not binary expressions\nfunction createBinaryExpression (operator : string, left : AllParamTypes, right : AllParamTypes) : IBinaryExpression | ILogicalExpression {\n  if (operator === '||' || operator === '&&') {\n    return { type: ParamNames.LogicalExpression, operator, left, right }\n  } else {\n    return { type: ParamNames.BinaryExpression, operator, left, right }\n  }\n}\n\nexport class ParamsParser {\n  private expr : string\n  private index : number\n  private length : number\n\n  constructor () {\n    this.expr = ''\n    this.index = 0\n    this.length = 0\n  }\n\n  public parse (expr : string) : AllParamTypes {\n    this.expr = expr\n    this.index = 0\n    this.length = expr.length\n\n    const nodes = []\n    let chI : number\n    let node\n\n    while (this.index < this.length) {\n      chI = this.charCodeAt(this.index)\n\n      // Expressions can be separated by semicolons, commas, or just inferred without any\n      // separators\n      if (chI === ECharCodes.SEMCOL_CODE || chI === ECharCodes.COMMA_CODE) {\n        this.index++ // ignore separators\n      } else {\n        // Try to gobble each expression individually\n        node = this.parseExpression()\n        if (node) {\n          // If we weren't able to find a binary expression and are out of room, then\n          // the expression passed in probably has too much\n          nodes.push(node)\n        } else if (this.index < this.length) {\n          throw new ParamError(`Unexpected \"${this.charAt(this.index)}\"`, this.index)\n        }\n      }\n    }\n\n    // If there's only one expression just try returning the expression\n    if (nodes.length === 1) {\n      return nodes[0]\n    } else {\n      return {\n        type: ParamNames.Compound,\n        body: nodes,\n      }\n    }\n  }\n\n  private charAt (i : number) : string {\n    return this.expr.charAt(i)\n  }\n\n  private charCodeAt (i : number) : number {\n    return this.expr.charCodeAt(i)\n  }\n\n  // Push `index` up to the next non-space character\n  private parseSpaces () {\n    let ch = this.charCodeAt(this.index)\n    // space or tab\n    while (isWhitespace(ch)) {\n      ch = this.charCodeAt(++this.index)\n    }\n  }\n\n  // The main parsing function. Much of this code is dedicated to ternary expressions\n  private parseExpression () : AllParamTypes | null {\n    const test = this.parseBinaryExpression()\n    this.parseSpaces()\n    return test\n  }\n\n  // Search for the operation portion of the string (e.g. `+`, `===`)\n  // Start by taking the longest possible binary operations (3 characters: `===`, `!==`, `>>>`)\n  // and move down from 3 to 2 to 1 character until a matching binary operation is found\n  // then, return that binary operation\n  private parseBinaryOp () : string | null {\n    this.parseSpaces()\n    let toCheck = this.expr.substr(this.index, maxBinopLen)\n    let tcLen = toCheck.length\n    while (tcLen > 0) {\n      if (binaryOps.hasOwnProperty(toCheck)) {\n        this.index += tcLen\n        return toCheck\n      }\n      toCheck = toCheck.substr(0, --tcLen)\n    }\n    return null\n  }\n\n  // This function is responsible for gobbling an individual expression,\n  // e.g. `1`, `1+2`, `a+(b*2)-Math.sqrt(2)`\n  private parseBinaryExpression () : AllParamTypes | null {\n    let node\n    let biop : string | null\n    let prec\n    let stack : Array<AllParamTypes | IBiopInfo>\n    let biopInfo\n    let fbiop\n    let left\n    let right\n    let i\n\n    // First, try to get the leftmost thing\n    // Then, check to see if there's a binary operator operating on that leftmost thing\n    left = this.parseToken()\n    biop = this.parseBinaryOp()\n\n    // If there wasn't a binary operator, just return the leftmost node\n    if (!biop) {\n      return left\n    }\n\n    // Otherwise, we need to start a stack to properly place the binary operations in their\n    // precedence structure\n    biopInfo = {\n      value: biop,\n      prec: binaryPrecedence(biop),\n    }\n\n    right = this.parseToken()\n    if (!right || !left) {\n      throw new ParamError(`Expected expression after ${biop}`, this.index)\n    }\n    stack = [left, biopInfo, right]\n\n    // Properly deal with precedence using [recursive descent](http://www.engr.mun.ca/~theo/Misc/exp_parsing.htm)\n    while (true) {\n      biop = this.parseBinaryOp()\n      if (!biop) {\n        break\n      }\n\n      prec = binaryPrecedence(biop)\n\n      if (prec === 0) {\n        break\n      }\n      biopInfo = { value: biop, prec }\n\n      // Reduce: make a binary expression from the three topmost entries.\n      while (stack.length > 2) {\n        fbiop = stack[stack.length - 2]\n        if (!isIBiopInfo(fbiop) || prec > fbiop.prec) {\n          break\n        }\n        right = stack.pop()\n        stack.pop()\n        left = stack.pop()\n        if (!isAllParamTypes(right) || !isAllParamTypes(left)) {\n          break\n        }\n        node = createBinaryExpression(fbiop.value, left, right)\n        stack.push(node)\n      }\n\n      node = this.parseToken()\n      if (!node) {\n        throw new ParamError(`Expected expression after ${biop}`, this.index)\n      }\n      stack.push(biopInfo, node)\n    }\n\n    i = stack.length - 1\n    node = stack[i]\n    while (i > 1) {\n      fbiop = stack[i - 1]\n      left = stack[i - 2]\n      if (!isIBiopInfo(fbiop) || !isAllParamTypes(left) || !isAllParamTypes(node)) {\n        throw new ParamError(`Expected expression`, this.index)\n      }\n      node = createBinaryExpression(fbiop.value, left, node)\n      i -= 2\n    }\n    if (!isAllParamTypes(node)) {\n      throw new ParamError(`Expected expression`, this.index)\n    }\n    return node\n  }\n\n  // An individual part of a binary expression:\n  // e.g. `foo.bar(baz)`, `1`, `\"abc\"`, `(a % 2)` (because it's in parenthesis)\n  private parseToken () : AllParamTypes | null {\n    let ch\n    let toCheck\n    let tcLen\n\n    this.parseSpaces()\n    ch = this.charCodeAt(this.index)\n\n    if (isDecimalDigit(ch) || ch === ECharCodes.PERIOD_CODE) {\n      // Char code 46 is a dot `.` which can start off a numeric literal\n      return this.parseNumericLiteral()\n    } else if (ch === ECharCodes.SQUOTE_CODE || ch === ECharCodes.DQUOTE_CODE) {\n      // Single or double quotes\n      return this.parseStringLiteral()\n    } else if (isIdentifierStart(ch) || ch === ECharCodes.OPAREN_CODE) { // open parenthesis\n      // `foo`, `bar.baz`\n      return this.parseVariable()\n    } else if (ch === ECharCodes.OBRACK_CODE) {\n      return this.parseArray()\n    } else {\n      toCheck = this.expr.substr(this.index, maxUnopLen)\n      tcLen = toCheck.length\n      while (tcLen > 0) {\n        if (unaryOps.hasOwnProperty(toCheck)) {\n          this.index += tcLen\n          return {\n            type: ParamNames.UnaryExpression,\n            operator: toCheck,\n            argument: this.parseToken(),\n            prefix: true,\n          } as IUnaryExpression\n        }\n        toCheck = toCheck.substr(0, --tcLen)\n      }\n    }\n    return null\n  }\n\n  // Parse simple numeric literals: `12`, `3.4`, `.5`. Do this by using a string to\n  // keep track of everything in the numeric literal and then calling `parseFloat` on that string\n  private parseNumericLiteral () : ILiteral {\n    let rawName = ''\n    let ch\n    let chCode\n    while (isDecimalDigit(this.charCodeAt(this.index))) {\n      rawName += this.charAt(this.index++)\n    }\n\n    if (this.charCodeAt(this.index) === ECharCodes.PERIOD_CODE) { // can start with a decimal marker\n      rawName += this.charAt(this.index++)\n\n      while (isDecimalDigit(this.charCodeAt(this.index))) {\n        rawName += this.charAt(this.index++)\n      }\n    }\n\n    ch = this.charAt(this.index)\n    if (ch === 'e' || ch === 'E') { // exponent marker\n      rawName += this.charAt(this.index++)\n      ch = this.charAt(this.index)\n      if (ch === '+' || ch === '-') { // exponent sign\n        rawName += this.charAt(this.index++)\n      }\n      while (isDecimalDigit(this.charCodeAt(this.index))) { // exponent itself\n        rawName += this.charAt(this.index++)\n      }\n      if (!isDecimalDigit(this.charCodeAt(this.index - 1))) {\n        throw new ParamError(`Expected exponent (${rawName}${this.charAt(this.index)})`, this.index)\n      }\n    }\n\n    chCode = this.charCodeAt(this.index)\n    // Check to make sure this isn't a variable name that start with a number (123abc)\n    if (isIdentifierStart(chCode)) {\n      throw new ParamError(`Variable names cannot start with a number (${rawName}${this.charAt(this.index)})`, this.index)\n    } else if (chCode === ECharCodes.PERIOD_CODE) {\n      throw new ParamError('Unexpected period', this.index)\n    }\n\n    return {\n      type: ParamNames.Literal,\n      value: parseFloat(rawName),\n      raw: rawName,\n    }\n  }\n\n  // Parses a string literal, staring with single or double quotes with basic support for escape codes\n  // e.g. `\"hello world\"`, `'this is\\nJSEP'`\n  private parseStringLiteral () : ILiteral {\n    let str = ''\n    const quote = this.charAt(this.index++)\n    let closed = false\n    let ch\n\n    while (this.index < this.length) {\n      ch = this.charAt(this.index++)\n      if (ch === quote) {\n        closed = true\n        break\n      } else if (ch === '\\\\') {\n        // Check for all of the common escape codes\n        ch = this.charAt(this.index++)\n        switch (ch) {\n          case 'n': str += '\\n'; break\n          case 'r': str += '\\r'; break\n          case 't': str += '\\t'; break\n          case 'b': str += '\\b'; break\n          case 'f': str += '\\f'; break\n          case 'v': str += '\\x0B'; break\n          default : str += `\\\\${ch}`\n        }\n      } else {\n        str += ch\n      }\n    }\n\n    if (!closed) {\n      throw new ParamError(`Unclosed quote after \"${str}\"`, this.index)\n    }\n\n    return {\n      type: ParamNames.Literal,\n      value: str,\n      raw: quote + str + quote,\n    }\n  }\n\n  // Gobbles only identifiers\n  // e.g.: `foo`, `_value`, `$x1`\n  // Also, this function checks if that identifier is a literal:\n  // (e.g. `true`, `false`, `null`) or `this`\n  private parseIdentifier () : IIdentifier | ILiteral {\n    let ch = this.charCodeAt(this.index)\n    const start = this.index\n    let identifier : string\n\n    if (isIdentifierStart(ch)) {\n      this.index++\n    } else {\n      throw new ParamError(`Unexpected ${this.charAt(this.index)}`, this.index)\n    }\n\n    while (this.index < this.length) {\n      ch = this.charCodeAt(this.index)\n      if (isIdentifierPart(ch)) {\n        this.index++\n      } else {\n        break\n      }\n    }\n    identifier = this.expr.slice(start, this.index)\n\n    if (literals.hasOwnProperty(identifier)) {\n      return {\n        type: ParamNames.Literal,\n        value: literals[identifier],\n        raw: identifier,\n      }\n    } else {\n      return {\n        type: ParamNames.Identifier,\n        name: identifier,\n      }\n    }\n  }\n\n  // Gobbles a list of arguments within the context of a function call\n  // or array literal. This function also assumes that the opening character\n  // `(` or `[` has already been gobbled, and gobbles expressions and commas\n  // until the terminator character `)` or `]` is encountered.\n  // e.g. `foo(bar, baz)`, `my_func()`, or `[bar, baz]`\n  private parseArguments (termination : number) : AllParamTypes[] {\n    let chI : number\n    const args : AllParamTypes[] = []\n    let node\n    let closed = false\n    while (this.index < this.length) {\n      this.parseSpaces()\n      chI = this.charCodeAt(this.index)\n      if (chI === termination) { // done parsing\n        closed = true\n        this.index++\n        break\n      } else if (chI === ECharCodes.COMMA_CODE) { // between expressions\n        this.index++\n      } else {\n        node = this.parseExpression()\n        if (!node || node.type === ParamNames.Compound) {\n          throw new ParamError('Expected comma', this.index)\n        }\n        args.push(node)\n      }\n    }\n    if (!closed) {\n      throw new ParamError(`Expected ${String.fromCharCode(termination)}`, this.index)\n    }\n    return args\n  }\n\n  // Gobble a non-literal variable name. This variable name may include properties\n  // e.g. `foo`, `bar.baz`, `foo['bar'].baz`\n  // It also gobbles function calls:\n  // e.g. `Math.acos(obj.angle)`\n  private parseVariable () : AllParamTypes | null {\n    let chI : number\n    chI = this.charCodeAt(this.index)\n    let node : AllParamTypes | null = chI === ECharCodes.OPAREN_CODE\n      ? this.parseGroup()\n      : this.parseIdentifier()\n\n    this.parseSpaces()\n    chI = this.charCodeAt(this.index)\n    while (chI === ECharCodes.PERIOD_CODE || chI === ECharCodes.OBRACK_CODE || chI === ECharCodes.OPAREN_CODE) {\n      this.index++\n      if (chI === ECharCodes.PERIOD_CODE) {\n        this.parseSpaces()\n        node = {\n          type: ParamNames.MemberExpression,\n          computed: false,\n          object: node,\n          property: this.parseIdentifier(),\n        } as IMemberExpression\n      } else if (chI === ECharCodes.OBRACK_CODE) {\n        node = {\n          type: ParamNames.MemberExpression,\n          computed: true,\n          object: node,\n          property: this.parseExpression(),\n        } as IMemberExpression\n        this.parseSpaces()\n        chI = this.charCodeAt(this.index)\n        if (chI !== ECharCodes.CBRACK_CODE) {\n          throw new ParamError('Unclosed [', this.index)\n        }\n        this.index++\n      } else if (chI === ECharCodes.OPAREN_CODE) {\n        // A function call is being made; gobble all the arguments\n        node = {\n          type: ParamNames.CallExpression,\n          arguments: this.parseArguments(ECharCodes.CPAREN_CODE),\n          callee: node,\n        } as ICallExpression\n      }\n      this.parseSpaces()\n      chI = this.charCodeAt(this.index)\n    }\n    return node\n  }\n\n  // Responsible for parsing a group of things within parentheses `()`\n  // This function assumes that it needs to gobble the opening parenthesis\n  // and then tries to gobble everything within that parenthesis, assuming\n  // that the next thing it should see is the close parenthesis. If not,\n  // then the expression probably doesn't have a `)`\n  private parseGroup () : AllParamTypes | null {\n    this.index++\n    const node = this.parseExpression()\n    this.parseSpaces()\n    if (this.charCodeAt(this.index) === ECharCodes.CPAREN_CODE) {\n      this.index++\n      return node\n    } else {\n      throw new ParamError('Unclosed (', this.index)\n    }\n  }\n\n  // Responsible for parsing Array literals `[1, 2, 3]`\n  // This function assumes that it needs to gobble the opening bracket\n  // and then tries to gobble the expressions as arguments.\n  private parseArray () : IArrayExpression {\n    this.index++\n    return {\n      type: ParamNames.ArrayExpression,\n      elements: this.parseArguments(ECharCodes.CBRACK_CODE),\n    }\n  }\n}\n","import { ParamsParser } from '../ParamsParser'\nimport { ENodeType } from '../Symbols'\nimport { ParamNames } from '../types/Params'\nimport { IToken } from '../types/Tokens'\n\nexport function cToken (type : ENodeType, start : number, end : number, text : string, params : string = '', isClose : boolean = false) : IToken {\n  const parser = new ParamsParser()\n  return {\n    type,\n    start,\n    end,\n    text,\n    params: params !== '' ? parser.parse(params) : {\n      type : ParamNames.Empty,\n    },\n    isClose,\n  }\n}\n","import ParamError from './errors/ParamError'\nimport { ENodeType, ISymbol, symbols } from './Symbols'\nimport { IToken } from './types/Tokens'\nimport { ECharCodes, isLetter, isWhitespace } from './utils/Chars'\nimport { cToken } from './utils/Params'\n\ninterface INextPos {\n  pos : number\n  text : string\n}\n\nexport class Tokenizer {\n  private template : string = ''\n  private tokens : IToken[] = []\n  private cursorPos : number = 0\n\n  public parse (template : string) : IToken[] {\n    this.template = template\n    this.tokens = []\n    this.cursorPos = 0\n    while (this.cursorPos >= 0 && this.cursorPos < this.template.length) {\n      this.parseToken()\n    }\n\n    return this.tokens\n  }\n\n  private getNextPos (items : string[]) : INextPos {\n    let pos = -1\n    let text = ''\n    for (const item of items) {\n      const n = this.template.indexOf(item, this.cursorPos)\n      if (n >= 0 && (pos === -1 || n < pos)) {\n        pos = n\n        text = item\n      }\n    }\n    return { pos, text }\n  }\n\n  private parseTag () : string {\n    let text : string = ''\n    let ch : number = this.charCodeAt(this.cursorPos)\n\n    while (this.cursorPos < this.template.length) {\n      if (isWhitespace(ch) ||\n        ch === ECharCodes.GREATER_THAN ||\n        (ch === ECharCodes.SLASH && this.charCodeAt(this.cursorPos + 1) === ECharCodes.GREATER_THAN)\n      ) {\n        break\n      }\n      if (isLetter(ch) || ch === ECharCodes.PERIOD_CODE) {\n        text += this.charAt(this.cursorPos)\n        ch = this.charCodeAt(++this.cursorPos)\n      } else {\n        throw new ParamError(`Invalid \\`${this.charAt(this.cursorPos)}\\``, this.cursorPos)\n      }\n    }\n    return text\n  }\n\n  private getToken () : ISymbol | null {\n    let symbol : ISymbol | null = null\n    let startPos : number = 0\n    for (const item of symbols) {\n      const n = this.template.indexOf(item.startToken, this.cursorPos)\n      if (n >= 0 && (!symbol || n < startPos)) {\n        symbol = item\n        startPos = n\n      }\n    }\n    return symbol || null\n  }\n\n  private parseToken () {\n    let text : string = ''\n    const startPos = this.cursorPos\n    let ch : number\n    while (this.cursorPos < this.template.length) {\n      ch = this.charCodeAt(this.cursorPos)\n      if (ch === ECharCodes.LESS_THAN || ch === ECharCodes.DOLAR) { // <\n        const token = this.getToken()\n        if (token) {\n          if (text.length > 0) {\n            this.addToken(ENodeType.Text, startPos, this.cursorPos, text)\n            text = ''\n          }\n\n          const start = this.cursorPos\n          this.cursorPos += token.startToken.length\n\n          switch (token.type) {\n            case ENodeType.Comment: // <#-- foo -->\n              this.parseComment(start)\n              return\n            case ENodeType.Directive: // <#foo> | </#foo>\n              this.parseDirective(start, Boolean(token.end))\n              return\n            case ENodeType.Macro: // <@foo> | </@foo>\n              this.parseMacro(start, Boolean(token.end))\n              return\n            case ENodeType.Interpolation: // ${ foo?string }\n              this.parseInterpolation(start)\n              return\n          }\n          break\n        }\n      }\n      text += this.charAt(this.cursorPos)\n      ++this.cursorPos\n    }\n\n    if (text.length > 0) {\n      this.addToken(ENodeType.Text, startPos, this.cursorPos, text)\n    }\n\n    return\n  }\n\n  private addToken (type : ENodeType, start : number, end : number, text : string, params : string = '', isClose : boolean = false) {\n    this.tokens.push(cToken(type, start, end, text, params, isClose))\n  }\n\n  private parseComment (start : number) {\n    const end = this.getNextPos(['-->'])\n    if (end.pos === -1) {\n      throw new ReferenceError(`Unclosed comment`)\n    }\n    const text = this.template.substring(this.cursorPos, end.pos)\n    this.cursorPos = end.pos + end.text.length\n\n    this.addToken(ENodeType.Comment, start, this.cursorPos, text)\n  }\n\n  private parseInterpolation (start : number) {\n    const params = this.parseParams(['}'])\n    this.addToken(ENodeType.Interpolation, start, this.cursorPos, '', params)\n  }\n\n  private parseMacro (start : number, isClose : boolean) {\n    const typeString = this.parseTag()\n    if (typeString.length === 0) {\n      throw new ParamError('Macro name cannot be empty', this.cursorPos)\n    }\n\n    const params = this.parseParams(['>', '/>'])\n    this.addToken(ENodeType.Macro, start, this.cursorPos, typeString, params, isClose)\n  }\n\n  private parseDirective (start : number, isClose : boolean) {\n    const typeString = this.parseTag()\n    if (typeString.length === 0) {\n      throw new ParamError('Directive name cannot be empty', this.cursorPos)\n    }\n\n    const params = this.parseParams(['>', '/>'])\n\n    this.addToken(ENodeType.Directive, start, this.cursorPos, typeString, params, isClose)\n  }\n\n  // When you want to test if x > 0 or x >= 0, writing <#if x > 0> and <#if x >= 0> is WRONG,\n  // as the first > will close the #if tag. To work that around, write <#if x gt 0> or <#if gte 0>.\n  // Also note that if the comparison occurs inside parentheses, you will have no such problem,\n  // like <#if foo.bar(x > 0)> works as expected.\n  private parseParams (endTags : string[]) : string {\n    let paramText : string = ''\n    let bracketLevel = 0\n    let inString = false\n\n    while (this.cursorPos <= this.template.length) {\n      const ch = this.charCodeAt(this.cursorPos)\n      const char = this.charAt(this.cursorPos)\n      if (char === '\"') {\n        inString = !inString\n      }\n\n      if (!inString) {\n        if (ch === ECharCodes.OPAREN_CODE) {\n          ++bracketLevel\n        } else if (ch === ECharCodes.CPAREN_CODE) {\n          --bracketLevel\n        }\n      }\n\n      if (bracketLevel < 0) {\n        throw new SyntaxError(`bracketLevel < 0`) // TODO: add more info like location\n      }\n\n      if (bracketLevel === 0 && !inString) {\n        const nextPos = this.getNextPos(endTags)\n        if (nextPos.pos !== -1 && this.cursorPos === nextPos.pos) {\n          this.cursorPos += nextPos.text.length\n          return paramText\n        } else {\n          paramText += char\n          ++this.cursorPos\n        }\n      } else {\n        paramText += char\n        ++this.cursorPos\n      }\n    }\n    throw new SyntaxError(`Unclosed directive or macro`) // TODO: add more info like location\n  }\n\n  private charAt (i : number) : string {\n    return this.template.charAt(i)\n  }\n\n  private charCodeAt (i : number) : number {\n    return this.template.charCodeAt(i)\n  }\n}\n","import { IExpression } from './Params'\n\nexport enum NodeNames {\n  Program = 'Program',\n  Else = 'Else',\n  Condition = 'Condition',\n  Include = 'Include',\n  List = 'List',\n  Text = 'Text',\n  Assign = 'Assign',\n  Global = 'Global',\n  Local = 'Local',\n  Macro = 'Macro',\n  MacroCall = 'MacroCall',\n  Interpolation = 'Interpolation',\n  Attempt = 'Attempt',\n  Recover = 'Recover',\n  Comment = 'Comment',\n  Switch = 'Switch',\n  SwitchCase = 'SwitchCase',\n  SwitchDefault = 'SwitchDefault',\n  Break = 'Break',\n\n  ConditionElse = 'ConditionElse',\n\n  // Unsupported for now\n  // Function = 'Function',\n    // return = 'return',\n  // Flush = 'Flush',\n  // Local = 'Local',\n  // Lt = 'Lt',\n  // Nested = 'Nested',\n  // nt = 'nt',\n  // recurse = 'recurse',\n  // rt = 'rt',\n  // setting = 'setting',\n  // stop = 'stop',\n  // switch = 'switch',\n  //   // else = 'else',\n  //   case = 'case',\n  //   break = 'break',\n  // t = 't',\n  // visit = 'visit',\n}\n\nexport interface INode {\n  type : NodeNames\n  start : number\n  end : number\n}\n\nexport interface IProgram extends INode {\n  type : NodeNames.Program\n  body : INode[]\n}\n\nexport interface ICondition extends INode {\n  type : NodeNames.Condition\n  params : IExpression\n  consequent : INode[]\n  alternate? : INode[]\n}\n\nexport interface IInclude extends INode {\n  type : NodeNames.Include\n  params : IExpression\n}\n\nexport interface IList extends INode {\n  type : NodeNames.List\n  params : IExpression\n  body : INode[]\n  fallback? : INode[]\n}\n\nexport interface IText extends INode {\n  type : NodeNames.Text\n  text : string\n}\n\nexport interface IMacro extends INode {\n  type : NodeNames.Macro\n  params : IExpression\n  body : INode[]\n}\n\nexport interface IMacroCall extends INode {\n  type : NodeNames.MacroCall\n  params : IExpression\n  name : string\n  body? : INode[]\n}\n\nexport interface IAssign extends INode {\n  type : NodeNames.Assign\n  params : IExpression\n}\n\nexport interface IGlobal extends INode {\n  type : NodeNames.Global\n  params : IExpression\n}\n\nexport interface ILocal extends INode {\n  type : NodeNames.Local\n  params : IExpression\n}\n\nexport interface IInterpolation extends INode {\n  type : NodeNames.Interpolation\n  params : IExpression\n}\n\nexport interface IAttempt extends INode {\n  type : NodeNames.Attempt\n  body : INode[]\n  fallback? : INode[]\n}\n\nexport interface IComment extends INode {\n  type : NodeNames.Comment\n  text : string\n}\n\nexport interface ISwitch extends INode {\n  type : NodeNames.Switch\n  params : IExpression\n  cases : NodeSwitchGroup[]\n}\n\nexport interface ISwitchCase extends INode {\n  type : NodeNames.SwitchCase\n  params : IExpression\n  consequent : INode[]\n}\n\nexport interface ISwitchDefault extends INode {\n  type : NodeNames.SwitchDefault\n  consequent : INode[]\n}\n\nexport interface IBreak extends INode {\n  type : NodeNames.Break\n}\n\nexport type NodeSwitchGroup = ISwitchCase | ISwitchDefault\n\nexport type AllNodeTypes = IInterpolation | IMacroCall | IProgram | IText | IComment |\n  ICondition | IList |\n  IGlobal | ILocal | IAssign |\n  IInclude |\n  IMacro |\n  IAttempt |\n  ISwitch | ISwitchCase | ISwitchDefault |\n  IBreak\n","import {\n  IAssign,\n  IAttempt,\n  IBreak,\n  IComment,\n  ICondition,\n  IGlobal,\n  IInclude,\n  IInterpolation,\n  IList,\n  ILocal,\n  IMacro,\n  IMacroCall,\n  IProgram,\n  ISwitch,\n  ISwitchCase,\n  ISwitchDefault,\n  IText,\n  NodeNames,\n} from '../types/Node'\nimport { IExpression } from '../types/Params'\n\nexport function cAssign (params : IExpression, start : number, end : number) : IAssign {\n  return { type : NodeNames.Assign, start, end, params }\n}\n\nexport function cGlobal (params : IExpression, start : number, end : number) : IGlobal {\n  return { type : NodeNames.Global, start, end, params }\n}\n\nexport function cCondition (params : IExpression, start : number, end : number) : ICondition {\n  return { type : NodeNames.Condition, start, end, params, consequent: [] }\n}\n\nexport function cList (params : IExpression, start : number, end : number) : IList {\n  return { type : NodeNames.List, start, end, params, body : [] }\n}\n\nexport function cMacro (params : IExpression, start : number, end : number) : IMacro {\n  return { type : NodeNames.Macro, start, end, params, body : [] }\n}\n\nexport function cProgram (start : number, end : number) : IProgram {\n  return { type : NodeNames.Program, start, end, body : [] }\n}\n\nexport function cMacroCall (params : IExpression, name : string, start : number, end : number) : IMacroCall {\n  return { type : NodeNames.MacroCall, start, end, name, params, body : [] }\n}\n\nexport function cText (text : string, start : number, end : number) : IText {\n  return { type : NodeNames.Text, start, end, text }\n}\n\nexport function cInclude (params : IExpression, start : number, end : number) : IInclude {\n  return { type : NodeNames.Include, start, end, params }\n}\n\nexport function cInterpolation (params : IExpression, start : number, end : number) : IInterpolation {\n  return { type : NodeNames.Interpolation, start, end, params }\n}\n\nexport function cLocal (params : IExpression, start : number, end : number) : ILocal {\n  return { type : NodeNames.Local, start, end, params }\n}\n\nexport function cAttempt (start : number, end : number) : IAttempt {\n  return { type : NodeNames.Attempt, start, end, body : [] }\n}\n\nexport function cComment (text : string, start : number, end : number) : IComment {\n  return { type : NodeNames.Comment, start, end, text }\n}\n\nexport function cSwitch (params : IExpression, start : number, end : number) : ISwitch {\n  return { type : NodeNames.Switch, start, end, params, cases: [] }\n}\n\nexport function cSwitchCase (params : IExpression, start : number, end : number) : ISwitchCase {\n  return { type : NodeNames.SwitchCase, start, end, params, consequent: [] }\n}\n\nexport function cSwitchDefault (start : number, end : number) : ISwitchDefault {\n  return { type : NodeNames.SwitchDefault, start, end, consequent: [] }\n}\n\nexport function cBreak (start : number, end : number) : IBreak {\n  return { type : NodeNames.Break, start, end }\n}\n","import { ENodeType } from '../Symbols'\nimport { NodeNames } from './Node'\nimport { IExpression } from './Params'\n\nexport interface IDirectivesTypes {\n  [n : string] : NodeNames\n}\n\nexport const directives : IDirectivesTypes = {\n  if: NodeNames.Condition,\n  else: NodeNames.Else,\n  elseif: NodeNames.ConditionElse,\n  list: NodeNames.List,\n  include: NodeNames.Include,\n  assign: NodeNames.Assign,\n  attempt: NodeNames.Attempt,\n  // compress: 'compress',\n  // escape: 'escape',\n  // noescape: 'noescape',\n  // fallback: 'fallback',\n  // function: 'function',\n  // flush: 'flush',\n  global: NodeNames.Global,\n  // import: 'import',\n  local: NodeNames.Local,\n  // lt: 'lt',\n  macro: NodeNames.Macro,\n  // nested: 'nested',\n  // nt: 'nt',\n  recover: NodeNames.Recover,\n  // recurse: 'recurse',\n  // return: 'return',\n  // rt: 'rt',\n  // setting: 'setting',\n  // stop: 'stop',\n  switch: NodeNames.Switch,\n  case: NodeNames.SwitchCase,\n  default: NodeNames.SwitchDefault,\n  break: NodeNames.Break,\n  // t: 't',\n  // visit: 'visit',\n}\n\nexport interface IToken {\n  type : ENodeType\n  start : number\n  end : number\n  params : IExpression\n  text : string\n  isClose : boolean\n}\n","import NodeError from '../errors/NodeError'\nimport { ENodeType } from '../Symbols'\nimport { AllNodeTypes, NodeNames } from '../types/Node'\nimport { directives, IToken } from '../types/Tokens'\nimport {\n  cAssign,\n  cAttempt,\n  cBreak,\n  cComment,\n  cCondition,\n  cGlobal,\n  cInclude,\n  cInterpolation,\n  cList,\n  cLocal,\n  cMacro,\n  cMacroCall,\n  cSwitch,\n  cSwitchCase,\n  cSwitchDefault,\n  cText,\n} from './Node'\n\nfunction addToNode (parent : AllNodeTypes, child : AllNodeTypes) : AllNodeTypes {\n  switch (parent.type) {\n    case NodeNames.Condition:\n      parent.alternate ? parent.alternate.push(child) : parent.consequent.push(child)\n      break\n    case NodeNames.List:\n      parent.fallback ? parent.fallback.push(child) : parent.body.push(child)\n      break\n    case NodeNames.Switch:\n      if (child.type === NodeNames.SwitchCase || child.type === NodeNames.SwitchDefault) {\n        parent.cases.push(child)\n      } else if (parent.cases.length === 0) {\n        if (child.type !== NodeNames.Text) {\n          throw new NodeError(`addToChild(${parent.type}, ${child.type}) failed`, child)\n        }\n      } else {\n        parent.cases[parent.cases.length - 1].consequent.push(child)\n      }\n      break\n    case NodeNames.Macro:\n    case NodeNames.Program:\n      parent.body.push(child)\n      break\n    case NodeNames.Attempt:\n      parent.fallback ? parent.fallback.push(child) : parent.body.push(child)\n      break\n    case NodeNames.MacroCall:\n    case NodeNames.Assign:\n    case NodeNames.Global:\n    case NodeNames.Local:\n      // TODO: only when multiline\n      throw new NodeError(`addToChild(${parent.type}, ${child.type}) failed`, child)\n    case NodeNames.Interpolation:\n    case NodeNames.Include:\n    case NodeNames.Text:\n    case NodeNames.Comment:\n    case NodeNames.SwitchDefault:\n    case NodeNames.SwitchCase:\n    case NodeNames.Break:\n    default:\n      throw new NodeError(`addToChild(${parent.type}, ${child.type}) failed`, child)\n  }\n  return child\n}\n\nexport function tokenToNodeType (token : IToken) : NodeNames {\n  switch (token.type) {\n    case ENodeType.Directive:\n      if (token.text in directives) {\n        return directives[token.text]\n      }\n      throw new NodeError(`Directive \\`${token.text}\\` is not supported`, token)\n    case ENodeType.Interpolation:\n      return NodeNames.Interpolation\n    case ENodeType.Text:\n      return NodeNames.Text\n    case ENodeType.Macro:\n      return NodeNames.MacroCall\n    case ENodeType.Program:\n      return NodeNames.Program\n    case ENodeType.Comment:\n      return NodeNames.Comment\n  }\n  throw new NodeError(`Unknow token \\`${token.type}\\` - \\`${token.text}\\``, token)\n}\n\nexport function addNodeChild (parent : AllNodeTypes, token : IToken) : AllNodeTypes {\n  const tokenType = tokenToNodeType(token)\n  // console.log(`addNodeChild(${parent.type}, ${tokenType})`)\n  switch (tokenType) {\n    case NodeNames.Else:\n      if (parent.type === NodeNames.Condition) {\n        if (parent.alternate) {\n          throw new NodeError(`addNodeChild(${parent.type}, ${tokenType}) is not supported`, token) // TODO: improve this message\n        }\n        parent.alternate = []\n        return parent\n      } else if (parent.type === NodeNames.List) {\n        if (parent.fallback) {\n          throw new NodeError(`addNodeChild(${parent.type}, ${tokenType}) is not supported`, token) // TODO: improve this message\n        }\n        parent.fallback = []\n        return parent\n      }\n      break\n    case NodeNames.ConditionElse:\n      if (parent.type === NodeNames.Condition) {\n        const node = cCondition(token.params, token.start, token.end)\n        if (parent.alternate) {\n          throw new NodeError(`addNodeChild(${parent.type}, ${tokenType}) is not supported`, token) // TODO: improve this message\n        }\n        parent.alternate = []\n        parent.alternate.push(node)\n        return node\n      }\n      break\n    case NodeNames.Recover:\n      if (parent.type === NodeNames.Attempt) {\n        if (parent.fallback) {\n          throw new NodeError(`addNodeChild(${parent.type}, ${tokenType}) is not supported`, token) // TODO: improve this message\n        }\n        parent.fallback = []\n        return parent\n      }\n      break\n    case NodeNames.SwitchCase:\n      if (parent.type === NodeNames.Switch) {\n        parent.cases.push(cSwitchCase(token.params, token.start, token.end))\n        return parent\n      }\n      break\n    case NodeNames.SwitchDefault:\n      if (parent.type === NodeNames.Switch) {\n        parent.cases.push(cSwitchDefault(token.start, token.end))\n        return parent\n      }\n      break\n    case NodeNames.Attempt:\n      return addToNode(parent, cAttempt(token.start, token.end))\n    case NodeNames.Condition:\n      return addToNode(parent, cCondition(token.params, token.start, token.end))\n    case NodeNames.List:\n      return addToNode(parent, cList(token.params, token.start, token.end))\n    case NodeNames.Global:\n      return addToNode(parent, cGlobal(token.params, token.start, token.end))\n    case NodeNames.Macro:\n      return addToNode(parent, cMacro(token.params, token.start, token.end))\n    case NodeNames.Assign:\n      return addToNode(parent, cAssign(token.params, token.start, token.end))\n    case NodeNames.Include:\n      return addToNode(parent, cInclude(token.params, token.start, token.end))\n    case NodeNames.Local:\n      return addToNode(parent, cLocal(token.params, token.start, token.end))\n    case NodeNames.Interpolation:\n      return addToNode(parent, cInterpolation(token.params, token.start, token.end))\n    case NodeNames.Text:\n      return addToNode(parent, cText(token.text, token.start, token.end))\n    case NodeNames.MacroCall:\n      return addToNode(parent, cMacroCall(token.params, token.text, token.start, token.end))\n    case NodeNames.Comment:\n      return addToNode(parent, cComment(token.text, token.start, token.end))\n    case NodeNames.Switch:\n      return addToNode(parent, cSwitch(token.params, token.start, token.end))\n    case NodeNames.Break:\n      return addToNode(parent, cBreak(token.start, token.end))\n    case NodeNames.Program:\n      // this should nevet happen\n  }\n  throw new NodeError(`addNodeChild(${parent.type}, ${tokenType}) is not supported`, token)\n}\n\nexport enum EClosingType {\n  No,\n  Yes,\n  Partial,\n  Ignore,\n}\n\nexport function isClosing (type : NodeNames, parentType : NodeNames, isClose : boolean) : EClosingType {\n  switch (type) {\n    case NodeNames.Program:\n    case NodeNames.Attempt:\n    case NodeNames.Macro:\n    case NodeNames.Condition:\n    case NodeNames.List:\n    case NodeNames.Switch:\n      return (type === parentType && isClose) ? EClosingType.Yes : EClosingType.No\n    case NodeNames.ConditionElse:\n      return NodeNames.Condition === parentType ? EClosingType.Partial : EClosingType.No\n    case NodeNames.Else:\n      return (NodeNames.Condition === parentType || NodeNames.List === parentType) ? EClosingType.Partial : EClosingType.No\n    case NodeNames.Recover:\n      return (NodeNames.Attempt === parentType) ? EClosingType.Partial : EClosingType.No\n    case NodeNames.MacroCall:\n      return EClosingType.Ignore // TODO: conditional\n    case NodeNames.Assign:\n    case NodeNames.Global:\n    case NodeNames.Local:\n      return EClosingType.Ignore // TODO: conditional based on params\n    case NodeNames.SwitchCase:\n    case NodeNames.SwitchDefault:\n      return EClosingType.Ignore\n    case NodeNames.Include:\n    case NodeNames.Text:\n    case NodeNames.Interpolation:\n    case NodeNames.Comment:\n    case NodeNames.Break:\n      return EClosingType.Ignore\n  }\n\n  throw new ReferenceError(`isClosing(${type}) failed`)\n}\n","import { format } from 'util'\nimport NodeError from './errors/NodeError'\n\nimport { Tokenizer } from './Tokenizer'\nimport { IToken } from './types/Tokens'\n\nimport { AllNodeTypes, IProgram } from './types/Node'\nimport { cProgram } from './utils/Node'\nimport { addNodeChild, EClosingType, isClosing, tokenToNodeType } from './utils/Token'\n\nexport interface IParserReturn {\n  ast : IProgram\n  tokens : IToken[]\n}\n\nconst errorMessages = {\n  [EClosingType.No]: 'Unexpected close tag \\`%s\\`',\n  [EClosingType.Ignore]: '\\`%s\\` can\\'t self close',\n  [EClosingType.Partial]: '\\`%s\\` can\\'t self close',\n}\n\nexport class Parser {\n  public parse (template : string) : IParserReturn {\n    const ast = cProgram(0, template.length)\n    const stack : AllNodeTypes[] = []\n    let parent : AllNodeTypes = ast\n\n    const tokenizer = new Tokenizer()\n    const tokens = tokenizer.parse(template)\n    if (tokens.length === 0) {\n      return { ast, tokens }\n    }\n\n    let token : IToken | null = null\n    for (token of tokens) {\n      const tokenType = tokenToNodeType(token)\n\n      const closing = isClosing(tokenType, parent.type, token.isClose)\n\n      if (token.isClose) {\n        if (closing !== EClosingType.Yes) {\n          throw new NodeError(format(errorMessages[closing], token.type), token)\n        }\n\n        const parentNode = stack.pop()\n        if (!parentNode) {\n          throw new NodeError(`Stack is empty`, token)\n        }\n        parent = parentNode\n\n      } else {\n        const node = addNodeChild(parent, token)\n        if (closing !== EClosingType.Ignore) {\n          if (closing !== EClosingType.Partial) {\n            stack.push(parent)\n          }\n          parent = node\n        }\n      }\n    }\n\n    if (stack.length > 0) {\n      throw new NodeError(`Unclosed tag`, token ? token : stack.pop())\n    }\n    return { ast, tokens }\n  }\n}\n"],"names":["format"],"mappings":"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"}