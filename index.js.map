{"version":3,"file":"index.js.map","sources":["src/Types.ts","src/NodeConfig.ts","src/ParserError.ts","src/Symbols.ts","src/nodes/BaseNode.ts","src/nodes/Directive.ts","src/nodes/Interpolation.ts","src/nodes/Macro.ts","src/nodes/Program.ts","src/nodes/Text.ts","src/tokens/Token.ts","src/Parser.ts"],"sourcesContent":["// TODO: create specific classes/objects for each of this types with additional fields required for them\nexport enum ENodeType {\n  Program = 'Program',\n  Directive = 'Directive',\n  Macro = 'Macro',\n  Text = 'Text',\n  Interpolation = 'Interpolation',\n}\n\n// TODO: change this to object with configuration\n// - allowParams\n// - allowchildren\n// - sub elements\nexport enum EType {\n  Program = '@program',\n  Text = '@text',\n  MacroCall = '@macro',\n  Interpolation = '@interpolation',\n  // Build in macro\n  if = 'if',\n    else = 'else',\n    elseif = 'elseif',\n  list = 'list',\n  include = 'include',\n  assign = 'assign',\n  attempt = 'attempt',\n  compress = 'compress',\n  escape = 'escape',\n    noescape = 'noescape',\n  fallback = 'fallback',\n  function = 'function',\n  flush = 'flush',\n  global = 'global',\n  import = 'import',\n  local = 'local',\n  lt = 'lt',\n  macro = 'macro',\n  nested = 'nested',\n  nt = 'nt',\n  recover = 'recover',\n  recurse = 'recurse',\n  return = 'return',\n  rt = 'rt',\n  setting = 'setting',\n  stop = 'stop',\n  switch = 'switch',\n    // else = 'else',\n    case = 'case',\n    break = 'break',\n  t = 't',\n  visit = 'visit',\n}\n","import { EType } from './Types'\n\nexport interface INodeConfig {\n  isSelfClosing : boolean\n}\n\nexport interface INodeConfigObj {\n  [c : string] : INodeConfig\n}\n// <div>\n// asddssdaasd\n// </div>\n\n// <div>\n// <assign c = 0>\n// asdasdassad\n// <assign c = 2>\n//  <@foo>\n//  ${c} = 0\n//  sdfsdsdf\n// </assign>\n//  ${c} = 2\n\n// <assign>\n//  <@foo>\n//  sdfsdsdf\n// </assign>\n\nexport const NodeConfig : INodeConfigObj = {\n  [EType.Program]: {\n    isSelfClosing: false,\n  },\n  [EType.Text]: {\n    isSelfClosing: true,\n  },\n  [EType.MacroCall]: {\n    isSelfClosing: true,\n  },\n  [EType.Interpolation]: {\n    isSelfClosing: true,\n  },\n  [EType.if]: {\n    isSelfClosing: false,\n  },\n\n  // Build in macro\n  [EType.include]: {\n    isSelfClosing: true,\n  },\n  [EType.assign]: {\n     isSelfClosing: true,\n  },\n  [EType.if]: {\n     isSelfClosing: false,\n  },\n  [EType.else]: {\n     isSelfClosing: false,\n  },\n  [EType.elseif]: {\n     isSelfClosing: false,\n  },\n  [EType.list]: {\n     isSelfClosing: false,\n  },\n  [EType.attempt]: {\n     isSelfClosing: false,\n  },\n  [EType.recurse]: {\n     isSelfClosing: true,\n  },\n  [EType.compress]: {\n     isSelfClosing: false,\n  },\n  [EType.escape]: {\n     isSelfClosing: false,\n  },\n  [EType.noescape]: {\n     isSelfClosing: false,\n  },\n  [EType.fallback]: {\n     isSelfClosing: true,\n  },\n  [EType.function]: {\n     isSelfClosing: false,\n  },\n  [EType.flush]: {\n     isSelfClosing: true,\n  },\n  [EType.global]: {\n     isSelfClosing: true,\n  },\n  [EType.import]: {\n     isSelfClosing: true,\n  },\n  [EType.local]: {\n     isSelfClosing: true,\n  },\n  [EType.lt]: {\n     isSelfClosing: true,\n  },\n  [EType.macro]: {\n     isSelfClosing: false,\n  },\n  [EType.nested]: {\n     isSelfClosing: true,\n  },\n  [EType.nt]: {\n     isSelfClosing: true,\n  },\n  [EType.recover]: {\n     isSelfClosing: true,\n  },\n  [EType.return]: {\n     isSelfClosing: true,\n  },\n  [EType.rt]: {\n     isSelfClosing: true,\n  },\n  [EType.setting]: {\n     isSelfClosing: true,\n  },\n  [EType.stop]: {\n     isSelfClosing: true,\n  },\n  [EType.switch]: {\n     isSelfClosing: true,\n  },\n  [EType.case]: {\n     isSelfClosing: true,\n  },\n  [EType.break]: {\n     isSelfClosing: true,\n  },\n  [EType.t]: {\n     isSelfClosing: true,\n  },\n  [EType.visit]: {\n     isSelfClosing: true,\n  },\n}\n","export default class ParserError extends Error {\n  constructor (m : string) {\n      super(m)\n\n      // Set the prototype explicitly.\n      Object.setPrototypeOf(this, ParserError.prototype)\n  }\n}\n","import { ENodeType } from './Types'\n\nexport interface ISymbol {\n  startToken : string\n  endToken : string\n  type : ENodeType\n  end : boolean\n}\n\nexport const symbols : ISymbol[] = [\n  { startToken: '</#', endToken: '>', type: ENodeType.Directive, end: true },\n  { startToken: '<#', endToken: '>', type: ENodeType.Directive, end: false },\n  { startToken: '<@', endToken: '>', type: ENodeType.Macro, end: false },\n  // tslint:disable-next-line:no-invalid-template-strings\n  { startToken: '${', endToken: '}', type: ENodeType.Interpolation, end: false },\n]\n\nexport const whitespaces : string[] = [\n  ' ',\n  '\\t',\n  '\\n',\n  '\\r',\n]\n","import { ENodeType } from '../Types'\n\nexport class BaseNode {\n  public type : ENodeType\n  public isSelfClosing : boolean\n  public start : number\n  public end : number\n  public children : BaseNode[]\n\n  constructor (nodeType : string, start : number, end : number, isSelfClosing : boolean = false) {\n    this.type = nodeType as ENodeType\n    this.isSelfClosing = isSelfClosing\n    this.start = start\n    this.end = end\n    this.children = []\n  }\n}\n","import { EType, ENodeType } from '../Types'\nimport { BaseNode } from './BaseNode'\n\nexport default class Directive extends BaseNode {\n  public name : EType\n  public params : string[]\n\n  constructor (name : EType, params : string[], start : number, end : number) {\n    super(ENodeType.Directive, start, end, true)\n    this.name = name\n    this.params = params\n  }\n}\n","import { ENodeType } from '../Types'\nimport { BaseNode } from './BaseNode'\n\nexport default class Interpolation extends BaseNode {\n  constructor (start : number, end : number) {\n    super(ENodeType.Interpolation, start, end, true)\n  }\n}\n","import { ENodeType } from '../Types'\nimport { BaseNode } from './BaseNode'\n\nexport default class Macro extends BaseNode {\n  public name : string\n  public params : string[]\n\n  constructor (name : string, params : string[], start : number, end : number) {\n    super(ENodeType.Macro, start, end, true)\n    this.name = name\n    this.params = params\n  }\n}\n","import { ENodeType } from '../Types'\nimport { BaseNode } from './BaseNode'\n\nexport default class ProgramNode extends BaseNode {\n  constructor (start : number, end : number) {\n    super(ENodeType.Program, start, end)\n  }\n}\n","import { ENodeType } from '../Types'\nimport { BaseNode } from './BaseNode'\n\nexport default class Text extends BaseNode {\n  public text : string = ''\n  constructor (text : string = '', start : number, end : number) {\n    super(ENodeType.Text, start, end, true)\n    this.text = text\n  }\n}\n","import { EType, ENodeType } from '../Types'\n\nexport class Token {\n  public startPos : number\n  public endPos : number\n  public type : EType\n  public symbol : ENodeType\n  public params : string[]\n  public tag : string\n  public isClose : boolean\n  public text : string\n\n  constructor (symbol : ENodeType, startPos : number, endPos : number, type : EType = EType.Text, params : string[] = [], tag : string = '', isClose : boolean = false, text : string = '') {\n    this.symbol = symbol\n    this.startPos = startPos\n    this.endPos = endPos\n    this.type = type\n    this.params = params\n    this.tag = tag\n    this.isClose = isClose\n    this.text = text\n  }\n}\n","import { INodeConfig, NodeConfig } from './NodeConfig'\nimport ParserError from './ParserError'\nimport { ISymbol, symbols, whitespaces } from './Symbols'\nimport { ENodeType, EType } from './Types'\n\nimport { BaseNode } from './nodes/BaseNode'\nimport Directive from './nodes/Directive'\nimport Interpolation from './nodes/Interpolation'\nimport Macro from './nodes/Macro'\nimport ProgramNode from './nodes/Program'\nimport Text from './nodes/Text'\n\nimport { Token } from './tokens/Token'\n\nexport class Parser {\n  private cursorPos : number = 0\n  private template : string = ''\n  private AST : ProgramNode\n  private tokens : Token[] = []\n\n  constructor () {\n    this.template = ''\n    this.cursorPos = 0\n  }\n\n  public parse (template : string) : ProgramNode {\n    this.template = template\n    this.tokens = []\n    this.AST = new ProgramNode(0, template.length)\n    this.cursorPos = 0\n    this.parseTokens()\n    this.buildAST()\n    return this.AST\n  }\n\n  private getConfig (type : EType) : INodeConfig {\n    const cfg = NodeConfig[type]\n    if (!cfg) {\n      throw new ParserError(`Invalid Token`) // TODO: add more info like location\n    }\n    return cfg\n  }\n\n  private buildAST () {\n    const stack : BaseNode[] = []\n    let parent : BaseNode = this.AST\n\n    for (const token of this.tokens) {\n      const cfg = this.getConfig(token.type)\n\n      if (cfg.isSelfClosing) {\n        if (token.isClose) {\n          throw new ParserError(`Self closing token can't have close tag`) // TODO: add more info like location\n        }\n        const node = this.makeNode(token)\n        parent.children.push(node)\n      } else if (token.isClose) {\n        let parentNode : BaseNode | undefined = parent\n        while (parentNode) {\n          if (parentNode.type === token.symbol) {\n            break\n          }\n          const parentCfg = this.getConfig(token.type)\n          if (!parentCfg.isSelfClosing) {\n            throw new ParserError(`Missing close tag`) // TODO: add more info like location\n          }\n          parentNode = stack.pop()\n        }\n\n        if (!parentNode) {\n          throw new ParserError(`Closing tag is not alowed here`) // TODO: add more info like location\n        }\n        parentNode = stack.pop()\n        if (!parentNode) {\n          throw new ParserError(`Closing tag is not alowed here`) // TODO: add more info like location\n        }\n        parent = parentNode\n\n      } else {\n        const node = this.makeNode(token)\n        parent.children.push(node)\n        stack.push(parent)\n        parent = node\n      }\n    }\n\n    if (stack.length > 0) {\n      throw new ParserError(`Unclosed tag`) // TODO: add more info like location\n    }\n  }\n\n  private parseTokens () {\n    while (this.cursorPos >= 0 && this.cursorPos < this.template.length) {\n      const token = this.parseToken()\n      if (!token) {\n        this.tokens.push(this.makeToken(ENodeType.Text, this.cursorPos, this.template.length))\n        break\n      }\n    }\n  }\n\n  private makeToken (symbol : ENodeType, startPos : number, endPos : number, type : EType = EType.Text, params : string[] = [], tag : string = '', isClose : boolean = false) : Token {\n    // Get text => this.template.substring(startPos, endPos),\n    return new Token(symbol, startPos, endPos, type, params, tag, isClose, type !== EType.Text ? '' : this.template.substring(startPos, endPos))\n  }\n\n  private makeNode (token : Token) : BaseNode {\n    switch (token.symbol) {\n      case ENodeType.Directive:\n        return new Directive(token.type, token.params, token.startPos, token.endPos)\n      case ENodeType.Macro:\n        return new Macro(token.tag, token.params, token.startPos, token.endPos)\n      case ENodeType.Interpolation:\n        return new Interpolation(token.startPos, token.endPos)\n      case ENodeType.Text:\n        return new Text(token.text, token.startPos, token.endPos)\n    }\n    throw new ParserError('Unknown symbol')\n  }\n\n  private getNextPos (items : string[]) : number {\n    let pos = -1\n    for (const item of items) {\n      const n = this.template.indexOf(item, this.cursorPos)\n      if (n >= 0 && (pos === -1 || n < pos)) {\n        pos = n\n      }\n    }\n    return pos\n  }\n\n  private parseTag (endTag : string) : string {\n    const pos = this.getNextPos([\n      ...whitespaces,\n      endTag,\n    ])\n    if (pos < 0) {\n      throw new ParserError('Missing closing tag') // TODO: add more info like location\n    }\n    return this.template.substring(this.cursorPos, pos)\n  }\n\n  private parseToken () : boolean {\n    let symbol : ISymbol | null = null\n    let startPos : number = 0\n    for (const item of symbols) {\n      const n = this.template.indexOf(item.startToken, this.cursorPos)\n      if (n >= 0 && (!symbol || n < startPos)) {\n        symbol = item,\n        startPos = n\n      }\n    }\n\n    if (!symbol) {\n      return false\n    }\n\n    if (startPos - 1 > this.cursorPos) {\n      this.tokens.push(this.makeToken(ENodeType.Text, this.cursorPos, startPos - 1))\n    }\n    this.cursorPos = startPos\n\n    this.cursorPos += symbol.startToken.length\n\n    let node : Token | null = null\n\n    switch (symbol.type) {\n      case ENodeType.Directive: // <#foo>/</#foo>\n        node = this.parseDirective(symbol, startPos, symbol.end)\n        break\n      case ENodeType.Macro: // <@foo>\n        node = this.parseMacro(symbol, startPos)\n        break\n      case ENodeType.Interpolation: // ${ foo?string }\n        node = this.parseInterpolation(symbol, startPos)\n        break\n      default:\n        break\n    }\n\n    if (node) {\n      this.tokens.push(node)\n    }\n\n    ++this.cursorPos\n    return true\n  }\n\n  private parseInterpolation (symbol : ISymbol, startPos : number) : Token {\n    const params : string[] = this.parseParams(symbol.endToken)\n    const node = this.makeToken(ENodeType.Interpolation, startPos, this.cursorPos, EType.Interpolation, params)\n    return node\n  }\n\n  private parseMacro (symbol : ISymbol, startPos : number) : Token {\n    const typeString = this.parseTag(symbol.endToken)\n    this.cursorPos += typeString.length\n\n    const params : string[] = typeString.endsWith(symbol.endToken) ? [] : this.parseParams(symbol.endToken)\n\n    const node = this.makeToken(ENodeType.Macro, startPos, this.cursorPos, EType.MacroCall, params, typeString)\n\n    return node\n  }\n\n  private parseDirective (symbol : ISymbol, startPos : number, isClose : boolean = false) : Token {\n    const typeString = this.parseTag(symbol.endToken)\n    if (!(typeString in EType)) {\n      throw new ParserError(`Unsupported directive ${typeString}`) // TODO: add more info like location\n    }\n    this.cursorPos += typeString.length\n\n    const params : string[] = typeString.endsWith(symbol.endToken) ? [] : this.parseParams(symbol.endToken)\n\n    const node = this.makeToken(ENodeType.Directive, startPos, this.cursorPos, typeString as EType, params, '', isClose)\n    // TODO; read params\n\n    return node\n  }\n\n  private isWhitespace (char : string) : boolean {\n    return char === ' ' || char === '\\t' || char === '\\r' || char === '\\n'\n  }\n\n  // foo?string\n  // foo.foo\n  // (foo * 2)\n  // <#if \"adsddsasd >\"\n  // <#if foo == 2>\n  // \"foo bar\"\n  // (foo > bar)\n  private parseParams (engTag : string) : string[] {\n    const text = this.template.substring(this.cursorPos)\n    const params : string[] = []\n    let paramText : string = ''\n    let paramPos : number = this.cursorPos\n    let bracketLevel = 0\n    let inString = false\n\n    for (const char of text) {\n      if (char === '\"') {\n        inString = !inString\n      }\n\n      if (!inString) {\n        if (char === '(') {\n          ++bracketLevel\n        } else if (char === ')') {\n          --bracketLevel\n        }\n      }\n\n      if (bracketLevel < 0) {\n        throw new ParserError(`bracketLevel < 0`) // TODO: add more info like location\n      }\n\n      if (bracketLevel === 0 && !inString) {\n        if (char === engTag) {\n          if (paramText !== '') {\n            params.push(paramText)\n            paramText = ''\n          }\n          this.cursorPos = paramPos + engTag.length\n          return params\n        } else if (this.isWhitespace(char)) {\n          if (paramText !== '') {\n            params.push(paramText)\n            paramText = ''\n          }\n          ++paramPos\n          this.cursorPos = paramPos\n        } else {\n          paramText += char\n          ++paramPos\n        }\n      } else {\n        paramText += char\n        ++paramPos\n      }\n    }\n    throw new ParserError(`Unclosed directive or macro`) // TODO: add more info like location\n  }\n}\n\n// When you want to test if x > 0 or x >= 0, writing <#if x > 0> and <#if x >= 0> is WRONG,\n// as the first > will close the #if tag. To work that around, write <#if x gt 0> or <#if gte 0>.\n// Also note that if the comparison occurs inside parentheses, you will have no such problem,\n// like <#if foo.bar(x > 0)> works as expected.\n"],"names":[],"mappings":"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"}