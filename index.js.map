{"version":3,"file":"index.js","sources":["src/errors/ParserError.ts","src/errors/NodeError.ts","src/Symbols.ts","src/nodes/Types.ts","src/errors/ParamError.ts","src/params/ParamsParser.ts","src/utils/Params.ts","src/tokens/Types.ts","src/Tokenizer.ts","src/utils/Node.ts","src/utils/Token.ts","src/Parser.ts"],"sourcesContent":["\r\nexport default class ParserError extends Error {\r\n  constructor (m : string) {\r\n    super(m)\r\n\r\n    // Set the prototype explicitly.\r\n    Object.setPrototypeOf(this, ParserError.prototype)\r\n  }\r\n}\r\n","import { AllNodeTypes } from '../nodes/Types'\r\nimport { IToken } from '../tokens/Types'\r\nimport ParserError from './ParserError'\r\n\r\nexport default class NodeError extends ParserError {\r\n  public el : AllNodeTypes | IToken\r\n\r\n  constructor (m : string, el : AllNodeTypes | IToken) {\r\n    m = `${el.type}(${el.start}-${el.end}) - ${m}`\r\n    super(m)\r\n    this.el = el\r\n  }\r\n}\r\n","export enum ENodeType {\r\n  Program,\r\n  Directive,\r\n  Macro,\r\n  Text,\r\n  Interpolation,\r\n}\r\n\r\nexport interface ISymbol {\r\n  startToken : string\r\n  endToken : string\r\n  type : ENodeType\r\n  end : boolean\r\n}\r\n\r\nexport const symbols : ISymbol[] = [\r\n  { startToken: '</#', endToken: '>', type: ENodeType.Directive, end: true },\r\n  { startToken: '<#', endToken: '>', type: ENodeType.Directive, end: false },\r\n  { startToken: '</@', endToken: '>', type: ENodeType.Macro, end: true },\r\n  { startToken: '<@', endToken: '>', type: ENodeType.Macro, end: false },\r\n  // tslint:disable-next-line:no-invalid-template-strings\r\n  { startToken: '${', endToken: '}', type: ENodeType.Interpolation, end: false },\r\n]\r\n\r\nexport const whitespaces : string[] = [\r\n  ' ',\r\n  '\\t',\r\n  '\\n',\r\n  '\\r',\r\n]\r\n\r\nexport function isWhitespace (char : string) : boolean {\r\n  for (const space of whitespaces) {\r\n    if (char === space) {\r\n      return true\r\n    }\r\n  }\r\n  return false\r\n}\r\n","import { IExpression } from '../params/Types'\r\n\r\nexport enum NodeNames {\r\n  Program = 'Program',\r\n  Else = 'Else',\r\n  Condition = 'Condition',\r\n  Include = 'Include',\r\n  List = 'List',\r\n  Text = 'Text',\r\n  Assign = 'Assign',\r\n  Global = 'Global',\r\n  Local = 'Local',\r\n  Macro = 'Macro',\r\n  MacroCall = 'MacroCall',\r\n  Interpolation = 'Interpolation',\r\n  Attempt = 'Attempt',\r\n  Recover = 'Recover',\r\n\r\n  ConditionElse = 'ConditionElse',\r\n\r\n  // Unsupported for now\r\n  // Function = 'Function',\r\n    // return = 'return',\r\n  // Flush = 'Flush',\r\n  // Local = 'Local',\r\n  // Lt = 'Lt',\r\n  // Nested = 'Nested',\r\n  // nt = 'nt',\r\n  // recurse = 'recurse',\r\n  // rt = 'rt',\r\n  // setting = 'setting',\r\n  // stop = 'stop',\r\n  // switch = 'switch',\r\n  //   // else = 'else',\r\n  //   case = 'case',\r\n  //   break = 'break',\r\n  // t = 't',\r\n  // visit = 'visit',\r\n}\r\n\r\nexport interface IParams extends Array<IExpression> {\r\n  [i : number] : IExpression\r\n}\r\n\r\nexport interface INode {\r\n  type : NodeNames\r\n  start : number\r\n  end : number\r\n}\r\n\r\nexport interface IProgram extends INode {\r\n  type : NodeNames.Program\r\n  body : INode[]\r\n}\r\n\r\nexport interface ICondition extends INode {\r\n  type : NodeNames.Condition\r\n  params : IParams\r\n  consequent : INode[]\r\n  alternate? : IElse | ICondition\r\n}\r\n\r\nexport interface IElse extends INode {\r\n  type : NodeNames.Else\r\n  body : INode[]\r\n}\r\n\r\nexport interface IInclude extends INode {\r\n  type : NodeNames.Include\r\n  params : IParams\r\n}\r\n\r\nexport interface IList extends INode {\r\n  type : NodeNames.List\r\n  params : IParams\r\n  body : INode[]\r\n  fallback? : IElse\r\n}\r\n\r\nexport interface IText extends INode {\r\n  type : NodeNames.Text\r\n  text : string\r\n}\r\n\r\nexport interface IMacro extends INode {\r\n  type : NodeNames.Macro\r\n  params : IParams\r\n  body : INode[]\r\n}\r\n\r\nexport interface IMacroCall extends INode {\r\n  type : NodeNames.MacroCall\r\n  params : IParams\r\n  name : string\r\n  body? : INode[]\r\n}\r\n\r\nexport interface IAssign extends INode {\r\n  type : NodeNames.Assign\r\n  params : IParams\r\n}\r\n\r\nexport interface IGlobal extends INode {\r\n  type : NodeNames.Global\r\n  params : IParams\r\n}\r\n\r\nexport interface ILocal extends INode {\r\n  type : NodeNames.Local\r\n  params : IParams\r\n}\r\n\r\nexport interface IInterpolation extends INode {\r\n  type : NodeNames.Interpolation\r\n  params : IParams\r\n}\r\n\r\nexport interface IAttempt extends INode {\r\n  type : NodeNames.Attempt\r\n  body : INode[]\r\n  fallback? : IRecover\r\n}\r\n\r\nexport interface IRecover extends INode {\r\n  type : NodeNames.Recover\r\n  body : INode[]\r\n}\r\n\r\nexport type AllNodeTypes = IInterpolation | IMacroCall | IProgram | IText |\r\n  ICondition | IElse | IList |\r\n  IGlobal | ILocal | IAssign |\r\n  IInclude |\r\n  IMacro |\r\n  IAttempt | IRecover\r\n","import ParserError from './ParserError'\r\n\r\nexport default class ParamError extends ParserError {\r\n  public index : number\r\n  public description : string\r\n\r\n  constructor (message : string, index : number) {\r\n    super(`${message} at character ${index}`)\r\n    this.description = message\r\n    this.index = index\r\n  }\r\n}\r\n","import ParamError from '../errors/ParamError'\r\nimport {\r\n  IArrayExpression,\r\n  IBinaryExpression,\r\n  IBinaryOperators,\r\n  ICallExpression,\r\n  IExpression,\r\n  IIdentifier,\r\n  ILiteral,\r\n  ILiteralOperators,\r\n  ILogicalExpression,\r\n  IMemberExpression,\r\n  IUnaryExpression,\r\n  IUnaryOperators,\r\n} from './Types'\r\n\r\n// This is the full set of types that any JSEP node can be.\r\n// Store them here to save space when minified\r\nconst COMPOUND = 'Compound'\r\nconst IDENTIFIER = 'Identifier'\r\nconst MEMBER_EXP = 'MemberExpression'\r\nconst LITERAL = 'Literal'\r\nconst CALL_EXP = 'CallExpression'\r\nconst UNARY_EXP = 'UnaryExpression'\r\nconst BINARY_EXP = 'BinaryExpression'\r\nconst LOGICAL_EXP = 'LogicalExpression'\r\nconst ARRAY_EXP = 'ArrayExpression'\r\n\r\nconst PERIOD_CODE = 46 // '.'\r\nconst COMMA_CODE  = 44 // ','\r\nconst SQUOTE_CODE = 39 // single quote\r\nconst DQUOTE_CODE = 34 // double quotes\r\nconst OPAREN_CODE = 40 // (\r\nconst CPAREN_CODE = 41 // )\r\nconst OBRACK_CODE = 91 // [\r\nconst CBRACK_CODE = 93 // ]\r\nconst SEMCOL_CODE = 59 // ;\r\n\r\n// Operations\r\n// ----------\r\n\r\n// Specify values directly\r\n// - Strings: \"Foo\" or 'Foo' or \"It's \\\"quoted\\\"\" or 'It\\'s \"quoted\"' or r\"C:\\raw\\string\"\r\n// - Numbers: 123.45\r\n// - Booleans: true, false\r\n// - Sequences: [\"foo\", \"bar\", 123.45];Ranges: 0..9, 0..<10 (or 0..!10), 0..\r\n// - Hashes: {\"name\":\"green mouse\", \"price\":150}\r\n// Retrieving variables\r\n// - Top-level variables: user\r\n// - Retrieving data from a hash: user.name, user[\"name\"]\r\n// - Retrieving data from a sequence: products[5]\r\n// - Special variable: .main\r\n// String operations\r\n// - Interpolation and concatenation: \"Hello ${user}!\" (or \"Hello \" + user + \"!\")\r\n// - Getting a character: name[0]\r\n// - String slice: Inclusive end: name[0..4], Exclusive end: name[0..<5], Length-based (lenient): name[0..*5], Remove starting: name[5..]\r\n// Sequence operations\r\n// - Concatenation: users + [\"guest\"]\r\n// - Sequence slice: Inclusive end: products[20..29], Exclusive end: products[20..<30], Length-based (lenient): products[20..*10], Remove starting: products[20..]\r\n// Hash operations\r\n// - Concatenation: passwords + { \"joe\": \"secret42\" }\r\n// - Arithmetical calculations: (x * 1.5 + 10) / 2 - y % 100\r\n// - Comparison: x == y, x != y, x < y, x > y, x >= y, x <= y, x lt y, x lte y, x gt y, x gte y, ...etc.\r\n// - Logical operations: !registered && (firstVisit || fromEurope)\r\n// - Built-ins: name?upper_case, path?ensure_starts_with('/')\r\n// - Method call: repeat(\"What\", 3)\r\n// Missing value handler operators:\r\n// - Default value: name!\"unknown\" or (user.name)!\"unknown\" or name! or (user.name)!\r\n// - Missing value test: name?? or (user.name)??\r\n// - Assignment operators: =, +=, -=, *=, /=, %=, ++, --\r\n\r\n// Use a quickly-accessible map to store all of the unary operators\r\nconst unaryOps : IUnaryOperators = {'-': true, '!': true, '~': true, '+': true, '?': true, '=': true}\r\n\r\n// see [Order of operations](http://en.wikipedia.org/wiki/Order_of_operations#Programming_language)\r\nconst binaryOps : IBinaryOperators = {\r\n  '||': 1,\r\n  '&&': 2,\r\n  '^': 4,\r\n  '&': 5,\r\n  '==': 6, '!=': 6, '===': 6, '!==': 6,\r\n  '<': 7, '>': 7, '<=': 7, '>=': 7, 'gt': 7, 'lt': 7, 'gte': 7, 'lte': 7,\r\n  '+': 9, '-': 9,\r\n  '*': 10, '/': 10, '%': 10,\r\n}\r\n\r\n// Get return the longest key length of any object\r\nfunction getMaxKeyLen (obj : object) {\r\n  let maxLen = 0\r\n  let len\r\n  for (const key in obj) {\r\n    if (obj.hasOwnProperty(key)) {\r\n      len = key.length\r\n      if (len > maxLen) {\r\n        maxLen = len\r\n      }\r\n    }\r\n  }\r\n  return maxLen\r\n}\r\n\r\nconst maxUnopLen = getMaxKeyLen(unaryOps)\r\nconst maxBinopLen = getMaxKeyLen(binaryOps)\r\n\r\n// Literals\r\n// ----------\r\n\r\n// Store the values to return for the various literals we may encounter\r\nconst literals : ILiteralOperators = {\r\n  true: true,\r\n  false: false,\r\n  null: null,\r\n}\r\n\r\ninterface IBiopInfo {\r\n  value : string\r\n  prec : number\r\n}\r\n\r\nfunction isIBiopInfo (object : any) : object is IBiopInfo {\r\n  return object && 'prec' in object\r\n}\r\n\r\nfunction isIExpression (object : any) : object is IExpression {\r\n  return object && 'type' in object\r\n}\r\n\r\n// Returns the precedence of a binary operator or `0` if it isn't a binary operator\r\nconst binaryPrecedence = (opVal : string) : number => binaryOps[opVal] || 0\r\n\r\n// Utility function (gets called from multiple places)\r\n// Also note that `a && b` and `a || b` are *logical* expressions, not binary expressions\r\nfunction createBinaryExpression (operator : string, left : IExpression, right : IExpression) : IBinaryExpression | ILogicalExpression | IExpression {\r\n  const type = (operator === '||' || operator === '&&') ? LOGICAL_EXP : BINARY_EXP\r\n  return {\r\n    type,\r\n    operator,\r\n    left,\r\n    right,\r\n  }\r\n}\r\n\r\n// `ch` is a character code in the next three functions\r\nfunction isDecimalDigit (ch : number) {\r\n  return ch >= 48 && ch <= 57 // 0...9\r\n}\r\n\r\n// any non-ASCII that is not an operator\r\nfunction isIdentifierStart (ch : number) {\r\n  return (\r\n    (ch === 36) || (ch === 95) || // a...z\r\n    (ch >= 65 && ch <= 90) || // `$` and `_`\r\n    (ch >= 97 && ch <= 122) || ch >= 128 // A...Z\r\n  ) && !binaryOps[String.fromCharCode(ch)]\r\n}\r\n\r\n// any non-ASCII that is not an operator\r\nfunction isIdentifierPart (ch : number) {\r\n  return (\r\n    (ch === 36) || (ch === 95) || // `$` and `_`\r\n    (ch >= 65 && ch <= 90) || // 0...9\r\n    (ch >= 97 && ch <= 122) || // A...Z\r\n    (ch >= 48 && ch <= 57) || // a...z\r\n    ch >= 128\r\n  ) && !binaryOps[String.fromCharCode(ch)]\r\n}\r\n\r\nexport class ParamsParser {\r\n  private expr : string\r\n  private index : number\r\n  private length : number\r\n\r\n  constructor () {\r\n    this.expr = ''\r\n    this.index = 0\r\n    this.length = 0\r\n  }\r\n\r\n  public parse (expr : string) {\r\n    this.expr = expr\r\n    this.index = 0\r\n    this.length = expr.length\r\n\r\n    const nodes = []\r\n    let chI : number\r\n    let node\r\n\r\n    while (this.index < this.length) {\r\n      chI = this.exprICode(this.index)\r\n\r\n      // Expressions can be separated by semicolons, commas, or just inferred without any\r\n      // separators\r\n      if (chI === SEMCOL_CODE || chI === COMMA_CODE) {\r\n        this.index++ // ignore separators\r\n      } else {\r\n        // Try to gobble each expression individually\r\n        node = this.parseExpression()\r\n        if (node) {\r\n          // If we weren't able to find a binary expression and are out of room, then\r\n          // the expression passed in probably has too much\r\n          nodes.push(node)\r\n        } else if (this.index < this.length) {\r\n          throw new ParamError(`Unexpected \"${this.exprI(this.index)}\"`, this.index)\r\n        }\r\n      }\r\n    }\r\n\r\n    // If there's only one expression just try returning the expression\r\n    if (nodes.length === 1) {\r\n      return nodes[0]\r\n    } else {\r\n      return {\r\n        type: COMPOUND,\r\n        body: nodes,\r\n      }\r\n    }\r\n  }\r\n\r\n  private exprI (i : number) {\r\n    return this.expr.charAt.call(this.expr, i)\r\n  }\r\n\r\n  private exprICode (i : number) {\r\n    return this.expr.charCodeAt.call(this.expr, i)\r\n  }\r\n\r\n  // Push `index` up to the next non-space character\r\n  private parseSpaces () {\r\n    let ch = this.exprICode(this.index)\r\n    // space or tab\r\n    while (ch === 32 || ch === 9 || ch === 10 || ch === 13) {\r\n      ch = this.exprICode(++this.index)\r\n    }\r\n  }\r\n\r\n  // The main parsing function. Much of this code is dedicated to ternary expressions\r\n  private parseExpression () : IExpression | null {\r\n    const test = this.parseBinaryExpression()\r\n    this.parseSpaces()\r\n    return test\r\n  }\r\n\r\n  // Search for the operation portion of the string (e.g. `+`, `===`)\r\n  // Start by taking the longest possible binary operations (3 characters: `===`, `!==`, `>>>`)\r\n  // and move down from 3 to 2 to 1 character until a matching binary operation is found\r\n  // then, return that binary operation\r\n  private parseBinaryOp () : string | null {\r\n    this.parseSpaces()\r\n    let toCheck = this.expr.substr(this.index, maxBinopLen)\r\n    let tcLen = toCheck.length\r\n    while (tcLen > 0) {\r\n      if (binaryOps.hasOwnProperty(toCheck)) {\r\n        this.index += tcLen\r\n        return toCheck\r\n      }\r\n      toCheck = toCheck.substr(0, --tcLen)\r\n    }\r\n    return null\r\n  }\r\n\r\n  // This function is responsible for gobbling an individual expression,\r\n  // e.g. `1`, `1+2`, `a+(b*2)-Math.sqrt(2)`\r\n  private parseBinaryExpression () : IExpression | null {\r\n    let node\r\n    let biop : string | null\r\n    let prec\r\n    let stack : Array<IExpression | IBiopInfo>\r\n    let biopInfo\r\n    let fbiop\r\n    let left\r\n    let right\r\n    let i\r\n\r\n    // First, try to get the leftmost thing\r\n    // Then, check to see if there's a binary operator operating on that leftmost thing\r\n    left = this.parseToken()\r\n    biop = this.parseBinaryOp()\r\n\r\n    // If there wasn't a binary operator, just return the leftmost node\r\n    if (!biop) {\r\n      return left\r\n    }\r\n\r\n    // Otherwise, we need to start a stack to properly place the binary operations in their\r\n    // precedence structure\r\n    biopInfo = {\r\n      value: biop,\r\n      prec: binaryPrecedence(biop),\r\n    }\r\n\r\n    right = this.parseToken()\r\n    if (!right || !left) {\r\n      throw new ParamError(`Expected expression after ${biop}`, this.index)\r\n    }\r\n    stack = [left, biopInfo, right]\r\n\r\n    // Properly deal with precedence using [recursive descent](http://www.engr.mun.ca/~theo/Misc/exp_parsing.htm)\r\n    while (true) {\r\n      biop = this.parseBinaryOp()\r\n      if (!biop) {\r\n        break\r\n      }\r\n\r\n      prec = binaryPrecedence(biop)\r\n\r\n      if (prec === 0) {\r\n        break\r\n      }\r\n      biopInfo = { value: biop, prec }\r\n\r\n      // Reduce: make a binary expression from the three topmost entries.\r\n      while (stack.length > 2) {\r\n        fbiop = stack[stack.length - 2]\r\n        if (!isIBiopInfo(fbiop) || prec > fbiop.prec) {\r\n          break\r\n        }\r\n        right = stack.pop()\r\n        stack.pop()\r\n        left = stack.pop()\r\n        if (!isIExpression(right) || !isIExpression(left)) {\r\n          break\r\n        }\r\n        node = createBinaryExpression(fbiop.value, left, right)\r\n        stack.push(node)\r\n      }\r\n\r\n      node = this.parseToken()\r\n      if (!node) {\r\n        throw new ParamError(`Expected expression after ${biop}`, this.index)\r\n      }\r\n      stack.push(biopInfo, node)\r\n    }\r\n\r\n    i = stack.length - 1\r\n    node = stack[i]\r\n    while (i > 1) {\r\n      fbiop = stack[i - 1]\r\n      left = stack[i - 2]\r\n      if (!isIBiopInfo(fbiop) || !isIExpression(left) || !isIExpression(node)) {\r\n        throw new ParamError(`Expected expression`, this.index)\r\n      }\r\n      node = createBinaryExpression(fbiop.value, left, node)\r\n      i -= 2\r\n    }\r\n    if (!isIExpression(node)) {\r\n      throw new ParamError(`Expected expression`, this.index)\r\n    }\r\n    return node\r\n  }\r\n\r\n  // An individual part of a binary expression:\r\n  // e.g. `foo.bar(baz)`, `1`, `\"abc\"`, `(a % 2)` (because it's in parenthesis)\r\n  private parseToken () : IUnaryExpression | IExpression | null {\r\n    let ch\r\n    let toCheck\r\n    let tcLen\r\n\r\n    this.parseSpaces()\r\n    ch = this.exprICode(this.index)\r\n\r\n    if (isDecimalDigit(ch) || ch === PERIOD_CODE) {\r\n      // Char code 46 is a dot `.` which can start off a numeric literal\r\n      return this.parseNumericLiteral()\r\n    } else if (ch === SQUOTE_CODE || ch === DQUOTE_CODE) {\r\n      // Single or double quotes\r\n      return this.parseStringLiteral()\r\n    } else if (isIdentifierStart(ch) || ch === OPAREN_CODE) { // open parenthesis\r\n      // `foo`, `bar.baz`\r\n      return this.parseVariable()\r\n    } else if (ch === OBRACK_CODE) {\r\n      return this.parseArray()\r\n    } else {\r\n      toCheck = this.expr.substr(this.index, maxUnopLen)\r\n      tcLen = toCheck.length\r\n      while (tcLen > 0) {\r\n        if (unaryOps.hasOwnProperty(toCheck)) {\r\n          this.index += tcLen\r\n          return {\r\n            type: UNARY_EXP,\r\n            operator: toCheck,\r\n            argument: this.parseToken(),\r\n            prefix: true,\r\n          }\r\n        }\r\n        toCheck = toCheck.substr(0, --tcLen)\r\n      }\r\n\r\n      return null\r\n    }\r\n  }\r\n\r\n  // Parse simple numeric literals: `12`, `3.4`, `.5`. Do this by using a string to\r\n  // keep track of everything in the numeric literal and then calling `parseFloat` on that string\r\n  private parseNumericLiteral () : ILiteral {\r\n    let rawName = ''\r\n    let ch\r\n    let chCode\r\n    while (isDecimalDigit(this.exprICode(this.index))) {\r\n      rawName += this.exprI(this.index++)\r\n    }\r\n\r\n    if (this.exprICode(this.index) === PERIOD_CODE) { // can start with a decimal marker\r\n      rawName += this.exprI(this.index++)\r\n\r\n      while (isDecimalDigit(this.exprICode(this.index))) {\r\n        rawName += this.exprI(this.index++)\r\n      }\r\n    }\r\n\r\n    ch = this.exprI(this.index)\r\n    if (ch === 'e' || ch === 'E') { // exponent marker\r\n      rawName += this.exprI(this.index++)\r\n      ch = this.exprI(this.index)\r\n      if (ch === '+' || ch === '-') { // exponent sign\r\n        rawName += this.exprI(this.index++)\r\n      }\r\n      while (isDecimalDigit(this.exprICode(this.index))) { // exponent itself\r\n        rawName += this.exprI(this.index++)\r\n      }\r\n      if (!isDecimalDigit(this.exprICode(this.index - 1))) {\r\n        throw new ParamError(`Expected exponent (${rawName}${this.exprI(this.index)})`, this.index)\r\n      }\r\n    }\r\n\r\n    chCode = this.exprICode(this.index)\r\n    // Check to make sure this isn't a variable name that start with a number (123abc)\r\n    if (isIdentifierStart(chCode)) {\r\n      throw new ParamError(`Variable names cannot start with a number (${rawName}${this.exprI(this.index)})`, this.index)\r\n    } else if (chCode === PERIOD_CODE) {\r\n      throw new ParamError('Unexpected period', this.index)\r\n    }\r\n\r\n    return {\r\n      type: LITERAL,\r\n      value: parseFloat(rawName),\r\n      raw: rawName,\r\n    }\r\n  }\r\n\r\n  // Parses a string literal, staring with single or double quotes with basic support for escape codes\r\n  // e.g. `\"hello world\"`, `'this is\\nJSEP'`\r\n  private parseStringLiteral () : ILiteral {\r\n    let str = ''\r\n    const quote = this.exprI(this.index++)\r\n    let closed = false\r\n    let ch\r\n\r\n    while (this.index < this.length) {\r\n      ch = this.exprI(this.index++)\r\n      if (ch === quote) {\r\n        closed = true\r\n        break\r\n      } else if (ch === '\\\\') {\r\n        // Check for all of the common escape codes\r\n        ch = this.exprI(this.index++)\r\n        switch (ch) {\r\n          case 'n': str += '\\n'; break\r\n          case 'r': str += '\\r'; break\r\n          case 't': str += '\\t'; break\r\n          case 'b': str += '\\b'; break\r\n          case 'f': str += '\\f'; break\r\n          case 'v': str += '\\x0B'; break\r\n          default : str += `\\\\${ch}`\r\n        }\r\n      } else {\r\n        str += ch\r\n      }\r\n    }\r\n\r\n    if (!closed) {\r\n      throw new ParamError(`Unclosed quote after \"${str}\"`, this.index)\r\n    }\r\n\r\n    return {\r\n      type: LITERAL,\r\n      value: str,\r\n      raw: quote + str + quote,\r\n    }\r\n  }\r\n\r\n  // Gobbles only identifiers\r\n  // e.g.: `foo`, `_value`, `$x1`\r\n  // Also, this function checks if that identifier is a literal:\r\n  // (e.g. `true`, `false`, `null`) or `this`\r\n  private parseIdentifier () : IIdentifier | ILiteral {\r\n    let ch = this.exprICode(this.index)\r\n    const start = this.index\r\n    let identifier : string\r\n\r\n    if (isIdentifierStart(ch)) {\r\n      this.index++\r\n    } else {\r\n      throw new ParamError(`Unexpected ${this.exprI(this.index)}`, this.index)\r\n    }\r\n\r\n    while (this.index < this.length) {\r\n      ch = this.exprICode(this.index)\r\n      if (isIdentifierPart(ch)) {\r\n        this.index++\r\n      } else {\r\n        break\r\n      }\r\n    }\r\n    identifier = this.expr.slice(start, this.index)\r\n\r\n    if (literals.hasOwnProperty(identifier)) {\r\n      return {\r\n        type: LITERAL,\r\n        value: literals[identifier],\r\n        raw: identifier,\r\n      }\r\n    } else {\r\n      return {\r\n        type: IDENTIFIER,\r\n        name: identifier,\r\n      }\r\n    }\r\n  }\r\n\r\n  // Gobbles a list of arguments within the context of a function call\r\n  // or array literal. This function also assumes that the opening character\r\n  // `(` or `[` has already been gobbled, and gobbles expressions and commas\r\n  // until the terminator character `)` or `]` is encountered.\r\n  // e.g. `foo(bar, baz)`, `my_func()`, or `[bar, baz]`\r\n  private parseArguments (termination : number) : IExpression[] {\r\n    let chI : number\r\n    const args : IExpression[] = []\r\n    let node\r\n    let closed = false\r\n    while (this.index < this.length) {\r\n      this.parseSpaces()\r\n      chI = this.exprICode(this.index)\r\n      if (chI === termination) { // done parsing\r\n        closed = true\r\n        this.index++\r\n        break\r\n      } else if (chI === COMMA_CODE) { // between expressions\r\n        this.index++\r\n      } else {\r\n        node = this.parseExpression()\r\n        if (!node || node.type === COMPOUND) {\r\n          throw new ParamError('Expected comma', this.index)\r\n        }\r\n        args.push(node)\r\n      }\r\n    }\r\n    if (!closed) {\r\n      throw new ParamError(`Expected ${String.fromCharCode(termination)}`, this.index)\r\n    }\r\n    return args\r\n  }\r\n\r\n  // Gobble a non-literal variable name. This variable name may include properties\r\n  // e.g. `foo`, `bar.baz`, `foo['bar'].baz`\r\n  // It also gobbles function calls:\r\n  // e.g. `Math.acos(obj.angle)`\r\n  private parseVariable () : IMemberExpression | IIdentifier | ILiteral | ICallExpression | IExpression | null {\r\n    let chI : number\r\n    chI = this.exprICode(this.index)\r\n    let node : IExpression | IIdentifier | ILiteral | IMemberExpression | ICallExpression | null = chI === OPAREN_CODE\r\n      ? this.parseGroup()\r\n      : this.parseIdentifier()\r\n\r\n    this.parseSpaces()\r\n    chI = this.exprICode(this.index)\r\n    while (chI === PERIOD_CODE || chI === OBRACK_CODE || chI === OPAREN_CODE) {\r\n      this.index++\r\n      if (chI === PERIOD_CODE) {\r\n        this.parseSpaces()\r\n        node = {\r\n          type: MEMBER_EXP,\r\n          computed: false,\r\n          object: node,\r\n          property: this.parseIdentifier(),\r\n        }\r\n      } else if (chI === OBRACK_CODE) {\r\n        node = {\r\n          type: MEMBER_EXP,\r\n          computed: true,\r\n          object: node,\r\n          property: this.parseExpression(),\r\n        }\r\n        this.parseSpaces()\r\n        chI = this.exprICode(this.index)\r\n        if (chI !== CBRACK_CODE) {\r\n          throw new ParamError('Unclosed [', this.index)\r\n        }\r\n        this.index++\r\n      } else if (chI === OPAREN_CODE) {\r\n        // A function call is being made; gobble all the arguments\r\n        node = {\r\n          type: CALL_EXP,\r\n          arguments: this.parseArguments(CPAREN_CODE),\r\n          callee: node,\r\n        }\r\n      }\r\n      this.parseSpaces()\r\n      chI = this.exprICode(this.index)\r\n    }\r\n    return node\r\n  }\r\n\r\n  // Responsible for parsing a group of things within parentheses `()`\r\n  // This function assumes that it needs to gobble the opening parenthesis\r\n  // and then tries to gobble everything within that parenthesis, assuming\r\n  // that the next thing it should see is the close parenthesis. If not,\r\n  // then the expression probably doesn't have a `)`\r\n  private parseGroup () : IExpression | null {\r\n    this.index++\r\n    const node = this.parseExpression()\r\n    this.parseSpaces()\r\n    if (this.exprICode(this.index) === CPAREN_CODE) {\r\n      this.index++\r\n      return node\r\n    } else {\r\n      throw new ParamError('Unclosed (', this.index)\r\n    }\r\n  }\r\n\r\n  // Responsible for parsing Array literals `[1, 2, 3]`\r\n  // This function assumes that it needs to gobble the opening bracket\r\n  // and then tries to gobble the expressions as arguments.\r\n  private parseArray () : IArrayExpression {\r\n    this.index++\r\n    return {\r\n      type: ARRAY_EXP,\r\n      elements: this.parseArguments(CBRACK_CODE),\r\n    }\r\n  }\r\n}\r\n","import { ParamsParser } from '../params/ParamsParser'\r\nimport { IParams } from '../Types'\r\n\r\nexport function parseParams (tokenParams : string[]) : IParams {\r\n  const parser = new ParamsParser()\r\n  const params : IParams = []\r\n  for (const param of tokenParams) {\r\n    params.push(parser.parse(param))\r\n  }\r\n  return params\r\n}\r\n","import { NodeNames } from '../nodes/Types'\r\nimport { ENodeType } from '../Symbols'\r\nimport { IParams } from '../Types'\r\nimport { parseParams } from '../utils/Params'\r\n\r\nexport interface IDirectivesTypes {\r\n  [n : string] : NodeNames\r\n}\r\n\r\nexport const directives : IDirectivesTypes = {\r\n  if: NodeNames.Condition,\r\n  else: NodeNames.Else,\r\n  elseif: NodeNames.ConditionElse,\r\n  list: NodeNames.List,\r\n  include: NodeNames.Include,\r\n  assign: NodeNames.Assign,\r\n  attempt: NodeNames.Attempt,\r\n  // compress: 'compress',\r\n  // escape: 'escape',\r\n  // noescape: 'noescape',\r\n  // fallback: 'fallback',\r\n  // function: 'function',\r\n  // flush: 'flush',\r\n  global: NodeNames.Global,\r\n  // import: 'import',\r\n  local: NodeNames.Local,\r\n  // lt: 'lt',\r\n  macro: NodeNames.Macro,\r\n  // nested: 'nested',\r\n  // nt: 'nt',\r\n  recover: NodeNames.Recover,\r\n  // recurse: 'recurse',\r\n  // return: 'return',\r\n  // rt: 'rt',\r\n  // setting: 'setting',\r\n  // stop: 'stop',\r\n  // switch: 'switch',\r\n  // case: 'case',\r\n  // break: 'break',\r\n  // t: 't',\r\n  // visit: 'visit',\r\n}\r\n\r\nexport interface IToken {\r\n  type : ENodeType\r\n  start : number\r\n  end : number\r\n  params : IParams\r\n  text : string\r\n  isClose : boolean\r\n}\r\n\r\nexport function cToken (type : ENodeType, start : number, end : number, text : string, params : string[] = [], isClose : boolean = false) : IToken {\r\n  return {\r\n    type,\r\n    start,\r\n    end,\r\n    params: parseParams(params),\r\n    text,\r\n    isClose,\r\n  }\r\n}\r\n","import ParserError from './errors/ParserError'\r\nimport { ENodeType, isWhitespace, ISymbol, symbols, whitespaces } from './Symbols'\r\nimport { cToken, IToken } from './tokens/Types'\r\n\r\nexport default class Tokenizer {\r\n  private template : string = ''\r\n  private tokens : IToken[] = []\r\n  private cursorPos : number = 0\r\n\r\n  public parse (template : string) : IToken[] {\r\n    this.template = template\r\n    while (this.cursorPos >= 0 && this.cursorPos < this.template.length) {\r\n      const token = this.parseToken()\r\n      if (!token) {\r\n        this.tokens.push(this.parseText(this.cursorPos, this.template.length))\r\n        break\r\n      }\r\n    }\r\n    return this.tokens\r\n  }\r\n\r\n  private getNextPos (items : string[]) : number {\r\n    let pos = -1\r\n    for (const item of items) {\r\n      const n = this.template.indexOf(item, this.cursorPos)\r\n      if (n >= 0 && (pos === -1 || n < pos)) {\r\n        pos = n\r\n      }\r\n    }\r\n    return pos\r\n  }\r\n\r\n  private parseTag (endTag : string) : string {\r\n    const pos = this.getNextPos([\r\n      ...whitespaces,\r\n      endTag,\r\n    ])\r\n    if (pos < 0) {\r\n      throw new ParserError('Missing closing tag') // TODO: add more info like location\r\n    }\r\n    return this.template.substring(this.cursorPos, pos)\r\n  }\r\n\r\n  private parseToken () : boolean {\r\n    let symbol : ISymbol | null = null\r\n    let startPos : number = 0\r\n    for (const item of symbols) {\r\n      const n = this.template.indexOf(item.startToken, this.cursorPos)\r\n      if (n >= 0 && (!symbol || n < startPos)) {\r\n        symbol = item,\r\n        startPos = n\r\n      }\r\n    }\r\n\r\n    if (!symbol) {\r\n      return false\r\n    }\r\n\r\n    if (startPos - 1 > this.cursorPos) {\r\n      this.tokens.push(this.parseText(this.cursorPos, startPos - 1))\r\n    }\r\n    this.cursorPos = startPos\r\n\r\n    this.cursorPos += symbol.startToken.length\r\n\r\n    let node : IToken | null = null\r\n\r\n    switch (symbol.type) {\r\n      case ENodeType.Directive: // <#foo>/</#foo>\r\n        node = this.parseDirective(symbol, startPos, symbol.end)\r\n        break\r\n      case ENodeType.Macro: // <@foo>\r\n        node = this.parseMacro(symbol, startPos, symbol.end)\r\n        break\r\n      case ENodeType.Interpolation: // ${ foo?string }\r\n        node = this.parseInterpolation(symbol, startPos)\r\n        break\r\n      default:\r\n        break\r\n    }\r\n\r\n    if (node) {\r\n      this.tokens.push(node)\r\n    }\r\n\r\n    ++this.cursorPos\r\n    return true\r\n  }\r\n\r\n  private parseText (start : number, end : number) : IToken {\r\n    return cToken(ENodeType.Text, start, end, this.template.substring(start, end))\r\n  }\r\n\r\n  private parseInterpolation (symbol : ISymbol, start : number) : IToken {\r\n    const params : string[] = this.parseParams(symbol.endToken)\r\n    return cToken(ENodeType.Interpolation, start, this.cursorPos, '', params)\r\n  }\r\n\r\n  private parseMacro (symbol : ISymbol, start : number, isClose : boolean = false) : IToken {\r\n    const typeString = this.parseTag(symbol.endToken)\r\n    this.cursorPos += typeString.length\r\n\r\n    const params : string[] = typeString.endsWith(symbol.endToken) ? [] : this.parseParams(symbol.endToken)\r\n\r\n    return cToken(ENodeType.Macro, start, this.cursorPos, typeString, params, isClose)\r\n  }\r\n\r\n  private parseDirective (symbol : ISymbol, startPos : number, isClose : boolean = false) : IToken {\r\n    const typeString = this.parseTag(symbol.endToken)\r\n    this.cursorPos += typeString.length\r\n\r\n    const params : string[] = typeString.endsWith(symbol.endToken) ? [] : this.parseParams(symbol.endToken)\r\n\r\n    return cToken(ENodeType.Directive, startPos, this.cursorPos, typeString, params, isClose)\r\n  }\r\n\r\n  // When you want to test if x > 0 or x >= 0, writing <#if x > 0> and <#if x >= 0> is WRONG,\r\n  // as the first > will close the #if tag. To work that around, write <#if x gt 0> or <#if gte 0>.\r\n  // Also note that if the comparison occurs inside parentheses, you will have no such problem,\r\n  // like <#if foo.bar(x > 0)> works as expected.\r\n  private parseParams (engTag : string) : string[] {\r\n    const text = this.template.substring(this.cursorPos)\r\n    const params : string[] = []\r\n    let paramText : string = ''\r\n    let paramPos : number = this.cursorPos\r\n    let bracketLevel = 0\r\n    let inString = false\r\n\r\n    for (const char of text) {\r\n      if (char === '\"') {\r\n        inString = !inString\r\n      }\r\n\r\n      if (!inString) {\r\n        if (char === '(') {\r\n          ++bracketLevel\r\n        } else if (char === ')') {\r\n          --bracketLevel\r\n        }\r\n      }\r\n\r\n      if (bracketLevel < 0) {\r\n        throw new ParserError(`bracketLevel < 0`) // TODO: add more info like location\r\n      }\r\n\r\n      if (bracketLevel === 0 && !inString) {\r\n        if (char === engTag) {\r\n          if (paramText !== '') {\r\n            params.push(paramText)\r\n            paramText = ''\r\n          }\r\n          this.cursorPos = paramPos + engTag.length\r\n          return params\r\n        } else if (isWhitespace(char)) {\r\n          if (paramText !== '') {\r\n            params.push(paramText)\r\n            paramText = ''\r\n          }\r\n          ++paramPos\r\n          this.cursorPos = paramPos\r\n        } else {\r\n          paramText += char\r\n          ++paramPos\r\n        }\r\n      } else {\r\n        paramText += char\r\n        ++paramPos\r\n      }\r\n    }\r\n    throw new ParserError(`Unclosed directive or macro`) // TODO: add more info like location\r\n  }\r\n}\r\n","import {\r\n  IAssign,\r\n  IAttempt,\r\n  ICondition,\r\n  IElse,\r\n  IGlobal,\r\n  IInclude,\r\n  IInterpolation,\r\n  IList,\r\n  ILocal,\r\n  IMacro,\r\n  IMacroCall,\r\n  IProgram,\r\n  IRecover,\r\n  IText,\r\n  NodeNames,\r\n} from '../nodes/Types'\r\n\r\nimport { IParams } from '../Types' // TODO remove this\r\n\r\nexport function cAssign (params : IParams, start : number, end : number) : IAssign {\r\n  return { type : NodeNames.Assign, params, start, end }\r\n}\r\n\r\nexport function cGlobal (params : IParams, start : number, end : number) : IGlobal {\r\n  return { type : NodeNames.Global, params, start, end }\r\n}\r\n\r\nexport function cCondition (params : IParams, start : number, end : number) : ICondition {\r\n  return { type : NodeNames.Condition, params, consequent: [], start, end }\r\n}\r\n\r\nexport function cElse (start : number, end : number) : IElse {\r\n  return { type : NodeNames.Else, body : [], start, end }\r\n}\r\n\r\nexport function cList (params : IParams, start : number, end : number) : IList {\r\n  return { type : NodeNames.List, params, body : [], start, end }\r\n}\r\n\r\nexport function cMacro (params : IParams, start : number, end : number) : IMacro {\r\n  return { type : NodeNames.Macro, params, body : [], start, end }\r\n}\r\n\r\nexport function cProgram (start : number, end : number) : IProgram {\r\n  return { type : NodeNames.Program, body : [], start, end }\r\n}\r\n\r\nexport function cMacroCall (params : IParams, name : string, start : number, end : number) : IMacroCall {\r\n  return { type : NodeNames.MacroCall, name, params, body : [], start, end }\r\n}\r\n\r\nexport function cText (text : string, start : number, end : number) : IText {\r\n  return { type : NodeNames.Text, text, start, end }\r\n}\r\n\r\nexport function cInclude (params : IParams, start : number, end : number) : IInclude {\r\n  return { type : NodeNames.Include, params, start, end }\r\n}\r\n\r\nexport function cInterpolation (params : IParams, start : number, end : number) : IInterpolation {\r\n  return { type : NodeNames.Interpolation, params, start, end }\r\n}\r\n\r\nexport function cLocal (params : IParams, start : number, end : number) : ILocal {\r\n  return { type : NodeNames.Local, params, start, end }\r\n}\r\n\r\nexport function cRecover (start : number, end : number) : IRecover {\r\n  return { type : NodeNames.Recover, body : [], start, end }\r\n}\r\n\r\nexport function cAttempt (start : number, end : number) : IAttempt {\r\n  return { type : NodeNames.Attempt, body : [], start, end }\r\n}\r\n","import ParserError from '../errors/ParserError'\r\nimport { AllNodeTypes, NodeNames } from '../nodes/Types'\r\nimport { ENodeType } from '../Symbols'\r\nimport { directives, IToken } from '../tokens/Types'\r\n\r\nimport {\r\n  cAssign,\r\n  cAttempt,\r\n  cCondition,\r\n  cElse,\r\n  cGlobal,\r\n  cInclude,\r\n  cInterpolation,\r\n  cList,\r\n  cLocal,\r\n  cMacro,\r\n  cMacroCall,\r\n  cRecover,\r\n  cText,\r\n} from './Node'\r\n\r\nfunction addToNode (parent : AllNodeTypes, child : AllNodeTypes) : AllNodeTypes {\r\n  switch (parent.type) {\r\n    case NodeNames.Condition:\r\n      parent.consequent.push(child)\r\n      break\r\n    case NodeNames.List:\r\n    case NodeNames.Else:\r\n    case NodeNames.Macro:\r\n    case NodeNames.Program:\r\n    case NodeNames.Attempt:\r\n    case NodeNames.Recover:\r\n      parent.body.push(child)\r\n      break\r\n    case NodeNames.MacroCall:\r\n    case NodeNames.Assign:\r\n    case NodeNames.Global:\r\n    case NodeNames.Local:\r\n      // TODO: only when multiline\r\n      throw new ParserError(`addToChild(${parent.type}, ${child.type}) failed`)\r\n    case NodeNames.Interpolation:\r\n    case NodeNames.Include:\r\n    case NodeNames.Text:\r\n    default:\r\n      throw new ParserError(`addToChild(${parent.type}, ${child.type}) failed`)\r\n  }\r\n  return child\r\n}\r\n\r\nexport function tokenToNodeType (token : IToken) : NodeNames {\r\n  switch (token.type) {\r\n    case ENodeType.Directive:\r\n      if (token.text in directives) {\r\n        return directives[token.text]\r\n      }\r\n      throw new ParserError(`Directive \\`${token.text}\\` is not supported`)\r\n    case ENodeType.Interpolation:\r\n      return NodeNames.Interpolation\r\n    case ENodeType.Text:\r\n      return NodeNames.Text\r\n    case ENodeType.Macro:\r\n      return NodeNames.Macro\r\n    case ENodeType.Program:\r\n      return NodeNames.Program\r\n  }\r\n  throw new ParserError(`Unknow token \\`${token.type}\\` - \\`${token.text}\\``)\r\n}\r\n\r\nexport function addNodeChild (parent : AllNodeTypes, token : IToken) : AllNodeTypes {\r\n  const tokenType = tokenToNodeType(token)\r\n  console.log(`addNodeChild(${parent.type}, ${tokenType})`)\r\n  switch (tokenType) {\r\n    case NodeNames.Else:\r\n      if (parent.type === NodeNames.Condition) {\r\n        return parent.alternate = cElse(token.start, token.end)\r\n      } else if (parent.type === NodeNames.List) {\r\n        return parent.fallback = cElse(token.start, token.end)\r\n      }\r\n      break\r\n    case NodeNames.ConditionElse:\r\n      if (parent.type === NodeNames.Condition) {\r\n        return parent.alternate = cCondition(token.params, token.start, token.end)\r\n      }\r\n      break\r\n    case NodeNames.Recover:\r\n      if (parent.type === NodeNames.Attempt) {\r\n        return parent.fallback = cRecover(token.start, token.end)\r\n      }\r\n      break\r\n    case NodeNames.Attempt:\r\n      return addToNode(parent, cAttempt(token.start, token.end))\r\n    case NodeNames.Condition:\r\n      return addToNode(parent, cCondition(token.params, token.start, token.end))\r\n    case NodeNames.List:\r\n      return addToNode(parent, cList(token.params, token.start, token.end))\r\n    case NodeNames.Global:\r\n      return addToNode(parent, cGlobal(token.params, token.start, token.end))\r\n    case NodeNames.Macro:\r\n      return addToNode(parent, cMacro(token.params, token.start, token.end))\r\n    case NodeNames.Assign:\r\n      return addToNode(parent, cAssign(token.params, token.start, token.end))\r\n    case NodeNames.Include:\r\n      return addToNode(parent, cInclude(token.params, token.start, token.end))\r\n    case NodeNames.Local:\r\n      return addToNode(parent, cLocal(token.params, token.start, token.end))\r\n    case NodeNames.Interpolation:\r\n      return addToNode(parent, cInterpolation(token.params, token.start, token.end))\r\n    case NodeNames.Text:\r\n      return addToNode(parent, cText(token.text, token.start, token.end))\r\n    case NodeNames.Macro:\r\n      return addToNode(parent, cMacroCall(token.params, token.text, token.start, token.end))\r\n    case NodeNames.Program:\r\n      // this should nevet happen\r\n  }\r\n  throw new ParserError(`addNodeChild(${parent.type}, ${tokenType}) is not supported`)\r\n}\r\n\r\nexport function isSelfClosing (type : NodeNames) : boolean {\r\n  switch (type) {\r\n    case NodeNames.Program:\r\n    case NodeNames.Condition:\r\n    case NodeNames.List:\r\n    case NodeNames.Attempt:\r\n    case NodeNames.Macro:\r\n      return false\r\n    case NodeNames.MacroCall:\r\n      return true // TODO: conditional\r\n    case NodeNames.Assign:\r\n    case NodeNames.Global:\r\n    case NodeNames.Local:\r\n      return true // TODO: conditional based on params\r\n    case NodeNames.Else:\r\n    case NodeNames.ConditionElse:\r\n    case NodeNames.Include:\r\n    case NodeNames.Text:\r\n    case NodeNames.Interpolation:\r\n    case NodeNames.Recover:\r\n      return true\r\n  }\r\n\r\n  throw new ParserError(`isSelfClosing(${type}) failed`)\r\n}\r\n","import NodeError from './errors/NodeError'\r\nimport ParserError from './errors/ParserError'\r\n\r\nimport Tokenizer from './Tokenizer'\r\n\r\nimport { AllNodeTypes, IProgram } from './nodes/Types'\r\nimport { cProgram } from './utils/Node'\r\nimport { addNodeChild, isSelfClosing, tokenToNodeType } from './utils/Token'\r\n\r\nexport class Parser {\r\n  public parse (template : string) : IProgram {\r\n    const astRoot = cProgram(0, template.length)\r\n    const stack : AllNodeTypes[] = []\r\n    let parent : AllNodeTypes = astRoot\r\n\r\n    const tokenizer = new Tokenizer()\r\n    const tokens = tokenizer.parse(template)\r\n\r\n    for (const token of tokens) {\r\n      const tokenType = tokenToNodeType(token)\r\n\r\n      if (isSelfClosing(tokenType)) {\r\n        if (token.isClose) {\r\n          throw new NodeError(`Unexpected close tag`, token)\r\n        }\r\n        addNodeChild(parent, token)\r\n      } else if (token.isClose) {\r\n        let parentNode : AllNodeTypes | undefined = parent\r\n        while (parentNode) {\r\n          if (parentNode.type === tokenType) {\r\n            parentNode = stack.pop()\r\n            break\r\n          }\r\n          if (!isSelfClosing(parentNode.type)) {\r\n            throw new NodeError(`Missing close tag ${tokenType}`, parentNode)\r\n          }\r\n          parentNode = stack.pop()\r\n        }\r\n\r\n        if (!parentNode) {\r\n          throw new NodeError(`Unexpected close tag`, token)\r\n        }\r\n        parent = parentNode\r\n\r\n      } else {\r\n        // parent = parent.addChild(node)\r\n        // stack.push(parent)\r\n        // parent = node\r\n        stack.push(parent)\r\n        parent = addNodeChild(parent, token)\r\n      }\r\n    }\r\n\r\n    if (stack.length > 0) {\r\n      throw new ParserError(`Unclosed tag`)\r\n    }\r\n    return astRoot\r\n  }\r\n}\r\n"],"names":[],"mappings":"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"}