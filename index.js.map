{"version":3,"file":"index.js","sources":["src/errors/ParserError.ts","src/errors/NodeError.ts","src/Types.ts","src/NodeConfig.ts","src/nodes/BaseNode.ts","src/nodes/Directive.ts","src/nodes/directives/IfCondtion.ts","src/nodes/directives/Include.ts","src/nodes/directives/List.ts","src/nodes/directives/UnknownDirective.ts","src/nodes/Interpolation.ts","src/nodes/Macro.ts","src/nodes/Text.ts","src/errors/ParamError.ts","src/params/ParamsParser.ts","src/NodeHelper.ts","src/nodes/Program.ts","src/Symbols.ts","src/tokens/Token.ts","src/Tokenizer.ts","src/Parser.ts"],"sourcesContent":["\nexport default class ParserError extends Error {\n  constructor (m : string) {\n    super(m)\n\n    // Set the prototype explicitly.\n    Object.setPrototypeOf(this, ParserError.prototype)\n  }\n}\n","import { BaseNode } from '../nodes/BaseNode'\nimport ParserError from './ParserError'\n\nexport default class NodeError extends ParserError {\n  public node : BaseNode\n\n  constructor (m : string, node : BaseNode) {\n    m = `${node.$nodeType}(${node.start}-${node.end}) - ${m}`\n    super(m)\n    this.node = node\n  }\n}\n","import { IExpression } from './params/Types'\n\n// TODO: create specific classes/objects for each of this types with additional fields required for them\nexport enum ENodeType {\n  Program = 'Program',\n  Directive = 'Directive',\n  Macro = 'Macro',\n  Text = 'Text',\n  Interpolation = 'Interpolation',\n}\n\n// TODO: change this to object with configuration\n// - allowParams\n// - allowchildren\n// - sub elements\nexport enum EType {\n  Program = '@program',\n  Text = '@text',\n  MacroCall = '@macro',\n  Interpolation = '@interpolation',\n  // Build in directive\n  if = 'if',\n    else = 'else',\n    elseif = 'elseif',\n  list = 'list',\n  include = 'include',\n  assign = 'assign',\n  attempt = 'attempt',\n  compress = 'compress',\n  escape = 'escape',\n    noescape = 'noescape',\n  fallback = 'fallback',\n  function = 'function',\n  flush = 'flush',\n  global = 'global',\n  import = 'import',\n  local = 'local',\n  lt = 'lt',\n  macro = 'macro',\n  nested = 'nested',\n  nt = 'nt',\n  recover = 'recover',\n  recurse = 'recurse',\n  return = 'return',\n  rt = 'rt',\n  setting = 'setting',\n  stop = 'stop',\n  switch = 'switch',\n    // else = 'else',\n    case = 'case',\n    break = 'break',\n  t = 't',\n  visit = 'visit',\n}\n\nexport interface IParams extends Array<IExpression> {\n  [i : number] : IExpression\n}\n","import { EType } from './Types'\n\nexport interface INodeConfig {\n  isSelfClosing : boolean\n  onlyIn? : EType[]\n  disallowParams? : boolean\n}\n\nexport interface INodeConfigObj {\n  [c : string] : INodeConfig\n}\n\nexport const NodeConfig : INodeConfigObj = {\n  [EType.Program]: {\n    isSelfClosing: false,\n    disallowParams: true,\n  },\n  [EType.Text]: {\n    isSelfClosing: true,\n    disallowParams: true,\n  },\n  [EType.MacroCall]: {\n    isSelfClosing: true,\n  },\n  [EType.Interpolation]: {\n    isSelfClosing: true,\n  },\n\n  // Build in macro\n  [EType.include]: {\n    isSelfClosing: true,\n  },\n  [EType.assign]: {\n    isSelfClosing: true,\n  },\n  [EType.if]: {\n    isSelfClosing: false,\n  },\n  [EType.else]: {\n    isSelfClosing: true,\n    onlyIn: [EType.if, EType.elseif, EType.list],\n    disallowParams: true,\n  },\n  [EType.elseif]: {\n    isSelfClosing: true,\n    onlyIn: [EType.if],\n  },\n  [EType.list]: {\n    isSelfClosing: false,\n  },\n  [EType.attempt]: {\n    isSelfClosing: false,\n  },\n  [EType.recurse]: {\n    isSelfClosing: true,\n  },\n  [EType.compress]: {\n    isSelfClosing: false,\n  },\n  [EType.escape]: {\n    isSelfClosing: false,\n  },\n  [EType.noescape]: {\n    isSelfClosing: false,\n  },\n  [EType.fallback]: {\n    isSelfClosing: true,\n  },\n  [EType.function]: {\n    isSelfClosing: false,\n  },\n  [EType.flush]: {\n    isSelfClosing: true,\n  },\n  [EType.global]: {\n    isSelfClosing: true,\n  },\n  [EType.import]: {\n    isSelfClosing: true,\n  },\n  [EType.local]: {\n    isSelfClosing: true,\n  },\n  [EType.lt]: {\n    isSelfClosing: true,\n  },\n  [EType.macro]: {\n    isSelfClosing: false,\n  },\n  [EType.nested]: {\n    isSelfClosing: true,\n  },\n  [EType.nt]: {\n    isSelfClosing: true,\n  },\n  [EType.recover]: {\n    isSelfClosing: true,\n  },\n  [EType.return]: {\n    isSelfClosing: true,\n  },\n  [EType.rt]: {\n    isSelfClosing: true,\n  },\n  [EType.setting]: {\n    isSelfClosing: true,\n  },\n  [EType.stop]: {\n    isSelfClosing: true,\n  },\n  [EType.switch]: {\n    isSelfClosing: true,\n  },\n  [EType.case]: {\n    isSelfClosing: true,\n  },\n  [EType.break]: {\n    isSelfClosing: true,\n  },\n  [EType.t]: {\n    isSelfClosing: true,\n  },\n  [EType.visit]: {\n    isSelfClosing: true,\n  },\n}\n","import NodeError from '../errors/NodeError'\nimport { INodeConfig, NodeConfig } from '../NodeConfig'\nimport { ENodeType, EType } from '../Types'\n\nexport class BaseNode {\n  public type : string\n  public $nodeType : ENodeType\n  public $eType : string\n  public start : number\n  public end : number\n  public $config : INodeConfig\n\n  constructor (nodeType : string, start : number, end : number, eType : EType) {\n    this.type = this.constructor.name\n    this.$nodeType = nodeType as ENodeType\n    this.$eType = eType\n    this.start = start\n    this.end = end\n    this.$config = NodeConfig[eType]\n    if (!this.$config) {\n      throw new NodeError(`Invalid Token`, this) // TODO: add more info like location\n    }\n  }\n\n  public canAddTo (node : BaseNode) : boolean {\n    return !this.$config.onlyIn || Boolean(this.$config.onlyIn.find((item) => item === node.$eType))\n  }\n\n  public addChild (node : BaseNode) : BaseNode {\n    throw new NodeError(`Unsupported ${this.constructor.name}:addChild(${node.$nodeType})`, this)\n  }\n}\n","import { ENodeType, EType, IParams } from '../Types'\nimport { BaseNode } from './BaseNode'\n\nexport default class Directive extends BaseNode {\n  public name : EType\n  public params : IParams\n\n  constructor (name : EType, params : IParams, start : number, end : number) {\n    super(ENodeType.Directive, start, end, name)\n    this.name = name\n    this.params = params\n  }\n}\n","import ParserError from '../../errors/ParserError'\nimport { EType, IParams } from '../../Types'\nimport { BaseNode } from '../BaseNode'\nimport Directive from '../Directive'\n\nexport default class IfCondtion extends Directive {\n  public consequent : BaseNode[]\n  public alternate : BaseNode[]\n  protected $inElse : boolean\n\n  constructor (name : EType, params : IParams, start : number, end : number) {\n    super(name, params, start, end)\n    this.consequent = []\n    this.alternate = []\n    this.$inElse = false\n  }\n\n  public addChild (node : BaseNode) : BaseNode {\n    if (node instanceof Directive) {\n      if ((node.name === EType.else || node.name === EType.elseif) && this.$inElse) {\n        throw new ParserError(`Unexpected token <#${node.name}>`)\n      }\n\n      if (node.name === EType.else) {\n        this.$inElse = true\n        return this\n      }\n      if (node.name === EType.elseif) {\n        this.$inElse = true\n        this.pushChild(node)\n        return node\n      }\n    }\n    this.pushChild(node)\n    return this\n  }\n\n  private pushChild (node : BaseNode) {\n    if (this.$inElse) {\n      this.alternate.push(node)\n    } else {\n      this.consequent.push(node)\n    }\n  }\n}\n","import NodeError from '../../errors/NodeError'\nimport { EType, IParams } from '../../Types'\nimport { BaseNode } from '../BaseNode'\nimport Directive from '../Directive'\n\nexport default class Include extends Directive {\n\n  constructor (name : EType, params : IParams, start : number, end : number) {\n    super(name, params, start, end)\n  }\n\n  public addChild (node : BaseNode) : BaseNode {\n    throw new NodeError(`Unsupported ${this.constructor.name}:addChild(${node.$nodeType})`, this)\n  }\n}\n","import ParserError from '../../errors/ParserError'\nimport { EType, IParams } from '../../Types'\nimport { BaseNode } from '../BaseNode'\nimport Directive from '../Directive'\n\nexport default class List extends Directive {\n  public body : BaseNode[]\n  public fallback : BaseNode[]\n  protected $inElse : boolean\n\n  constructor (name : EType, params : IParams, start : number, end : number) {\n    super(name, params, start, end)\n    this.body = []\n    this.fallback = []\n    this.$inElse = false\n  }\n\n  public addChild (node : BaseNode) : BaseNode {\n    if (node instanceof Directive) {\n      if (node.name === EType.else) {\n        if (this.$inElse) {\n          throw new ParserError(`Unexpected token <#${EType.else}>`)\n        }\n        this.$inElse = true\n        return this\n      }\n    }\n    this.pushChild(node)\n    return this\n  }\n\n  private pushChild (node : BaseNode) {\n    if (this.$inElse) {\n      this.fallback.push(node)\n    } else {\n      this.body.push(node)\n    }\n  }\n}\n","import { EType, IParams } from '../../Types'\nimport { BaseNode } from '../BaseNode'\nimport Directive from '../Directive'\n\nexport default class UnknownDirective extends Directive {\n  public children : BaseNode[]\n\n  constructor (name : EType, params : IParams, start : number, end : number) {\n    super(name, params, start, end)\n    this.children = []\n  }\n\n  public addChild (node : BaseNode) : BaseNode {\n    this.children.push(node)\n    return this\n  }\n}\n","import { ENodeType, EType, IParams } from '../Types'\nimport { BaseNode } from './BaseNode'\n\nexport default class Interpolation extends BaseNode {\n  public params : IParams\n\n  constructor (start : number, end : number, params : IParams) {\n    super(ENodeType.Interpolation, start, end, EType.Interpolation)\n    this.params = params\n  }\n}\n","import { ENodeType, EType, IParams } from '../Types'\nimport { BaseNode } from './BaseNode'\n\n// TODO: rename this\nexport default class Macro extends BaseNode {\n  public name : string\n  public params : IParams\n\n  constructor (name : string, params : IParams, start : number, end : number) {\n    super(ENodeType.Macro, start, end, EType.MacroCall)\n    this.name = name\n    this.params = params\n  }\n}\n","import { ENodeType, EType } from '../Types'\nimport { BaseNode } from './BaseNode'\n\nexport default class Text extends BaseNode {\n  public text : string = ''\n  constructor (text : string = '', start : number, end : number) {\n    super(ENodeType.Text, start, end, EType.Text)\n    this.text = text\n  }\n}\n","import ParserError from './ParserError'\n\nexport default class ParamError extends ParserError {\n  public index : number\n  public description : string\n\n  constructor (message : string, index : number) {\n    super(`${message} at character ${index}`)\n    this.description = message\n    this.index = index\n  }\n}\n","import ParamError from '../errors/ParamError'\nimport {\n  IArrayExpression,\n  IBinaryExpression,\n  IBinaryOperators,\n  ICallExpression,\n  IExpression,\n  IIdentifier,\n  ILiteral,\n  ILiteralOperators,\n  ILogicalExpression,\n  IMemberExpression,\n  IUnaryExpression,\n  IUnaryOperators,\n} from './Types'\n\n// This is the full set of types that any JSEP node can be.\n// Store them here to save space when minified\nconst COMPOUND = 'Compound'\nconst IDENTIFIER = 'Identifier'\nconst MEMBER_EXP = 'MemberExpression'\nconst LITERAL = 'Literal'\nconst CALL_EXP = 'CallExpression'\nconst UNARY_EXP = 'UnaryExpression'\nconst BINARY_EXP = 'BinaryExpression'\nconst LOGICAL_EXP = 'LogicalExpression'\nconst ARRAY_EXP = 'ArrayExpression'\n\nconst PERIOD_CODE = 46 // '.'\nconst COMMA_CODE  = 44 // ','\nconst SQUOTE_CODE = 39 // single quote\nconst DQUOTE_CODE = 34 // double quotes\nconst OPAREN_CODE = 40 // (\nconst CPAREN_CODE = 41 // )\nconst OBRACK_CODE = 91 // [\nconst CBRACK_CODE = 93 // ]\nconst SEMCOL_CODE = 59 // ;\n\n// Operations\n// ----------\n\n// Specify values directly\n// - Strings: \"Foo\" or 'Foo' or \"It's \\\"quoted\\\"\" or 'It\\'s \"quoted\"' or r\"C:\\raw\\string\"\n// - Numbers: 123.45\n// - Booleans: true, false\n// - Sequences: [\"foo\", \"bar\", 123.45];Ranges: 0..9, 0..<10 (or 0..!10), 0..\n// - Hashes: {\"name\":\"green mouse\", \"price\":150}\n// Retrieving variables\n// - Top-level variables: user\n// - Retrieving data from a hash: user.name, user[\"name\"]\n// - Retrieving data from a sequence: products[5]\n// - Special variable: .main\n// String operations\n// - Interpolation and concatenation: \"Hello ${user}!\" (or \"Hello \" + user + \"!\")\n// - Getting a character: name[0]\n// - String slice: Inclusive end: name[0..4], Exclusive end: name[0..<5], Length-based (lenient): name[0..*5], Remove starting: name[5..]\n// Sequence operations\n// - Concatenation: users + [\"guest\"]\n// - Sequence slice: Inclusive end: products[20..29], Exclusive end: products[20..<30], Length-based (lenient): products[20..*10], Remove starting: products[20..]\n// Hash operations\n// - Concatenation: passwords + { \"joe\": \"secret42\" }\n// - Arithmetical calculations: (x * 1.5 + 10) / 2 - y % 100\n// - Comparison: x == y, x != y, x < y, x > y, x >= y, x <= y, x lt y, x lte y, x gt y, x gte y, ...etc.\n// - Logical operations: !registered && (firstVisit || fromEurope)\n// - Built-ins: name?upper_case, path?ensure_starts_with('/')\n// - Method call: repeat(\"What\", 3)\n// Missing value handler operators:\n// - Default value: name!\"unknown\" or (user.name)!\"unknown\" or name! or (user.name)!\n// - Missing value test: name?? or (user.name)??\n// - Assignment operators: =, +=, -=, *=, /=, %=, ++, --\n\n// Use a quickly-accessible map to store all of the unary operators\nconst unaryOps : IUnaryOperators = {'-': true, '!': true, '~': true, '+': true, '?': true, '=': true}\n\n// see [Order of operations](http://en.wikipedia.org/wiki/Order_of_operations#Programming_language)\nconst binaryOps : IBinaryOperators = {\n  '||': 1,\n  '&&': 2,\n  '^': 4,\n  '&': 5,\n  '==': 6, '!=': 6, '===': 6, '!==': 6,\n  '<': 7, '>': 7, '<=': 7, '>=': 7, 'gt': 7, 'lt': 7, 'gte': 7, 'lte': 7,\n  '+': 9, '-': 9,\n  '*': 10, '/': 10, '%': 10,\n}\n\n// Get return the longest key length of any object\nfunction getMaxKeyLen (obj : object) {\n  let maxLen = 0\n  let len\n  for (const key in obj) {\n    if (obj.hasOwnProperty(key)) {\n      len = key.length\n      if (len > maxLen) {\n        maxLen = len\n      }\n    }\n  }\n  return maxLen\n}\n\nconst maxUnopLen = getMaxKeyLen(unaryOps)\nconst maxBinopLen = getMaxKeyLen(binaryOps)\n\n// Literals\n// ----------\n\n// Store the values to return for the various literals we may encounter\nconst literals : ILiteralOperators = {\n  true: true,\n  false: false,\n  null: null,\n}\n\ninterface IBiopInfo {\n  value : string\n  prec : number\n}\n\nfunction isIBiopInfo (object : any) : object is IBiopInfo {\n  return object && 'prec' in object\n}\n\nfunction isIExpression (object : any) : object is IExpression {\n  return object && 'type' in object\n}\n\n// Returns the precedence of a binary operator or `0` if it isn't a binary operator\nconst binaryPrecedence = (opVal : string) : number => binaryOps[opVal] || 0\n\n// Utility function (gets called from multiple places)\n// Also note that `a && b` and `a || b` are *logical* expressions, not binary expressions\nfunction createBinaryExpression (operator : string, left : IExpression, right : IExpression) : IBinaryExpression | ILogicalExpression | IExpression {\n  const type = (operator === '||' || operator === '&&') ? LOGICAL_EXP : BINARY_EXP\n  return {\n    type,\n    operator,\n    left,\n    right,\n  }\n}\n\n// `ch` is a character code in the next three functions\nfunction isDecimalDigit (ch : number) {\n  return ch >= 48 && ch <= 57 // 0...9\n}\n\n// any non-ASCII that is not an operator\nfunction isIdentifierStart (ch : number) {\n  return (\n    (ch === 36) || (ch === 95) || // a...z\n    (ch >= 65 && ch <= 90) || // `$` and `_`\n    (ch >= 97 && ch <= 122) || ch >= 128 // A...Z\n  ) && !binaryOps[String.fromCharCode(ch)]\n}\n\n// any non-ASCII that is not an operator\nfunction isIdentifierPart (ch : number) {\n  return (\n    (ch === 36) || (ch === 95) || // `$` and `_`\n    (ch >= 65 && ch <= 90) || // 0...9\n    (ch >= 97 && ch <= 122) || // A...Z\n    (ch >= 48 && ch <= 57) || // a...z\n    ch >= 128\n  ) && !binaryOps[String.fromCharCode(ch)]\n}\n\nexport class ParamsParser {\n  private expr : string\n  private index : number\n  private length : number\n\n  constructor () {\n    this.expr = ''\n    this.index = 0\n    this.length = 0\n  }\n\n  public parse (expr : string) {\n    this.expr = expr\n    this.index = 0\n    this.length = expr.length\n\n    const nodes = []\n    let chI : number\n    let node\n\n    while (this.index < this.length) {\n      chI = this.exprICode(this.index)\n\n      // Expressions can be separated by semicolons, commas, or just inferred without any\n      // separators\n      if (chI === SEMCOL_CODE || chI === COMMA_CODE) {\n        this.index++ // ignore separators\n      } else {\n        // Try to gobble each expression individually\n        node = this.parseExpression()\n        if (node) {\n          // If we weren't able to find a binary expression and are out of room, then\n          // the expression passed in probably has too much\n          nodes.push(node)\n        } else if (this.index < this.length) {\n          throw new ParamError(`Unexpected \"${this.exprI(this.index)}\"`, this.index)\n        }\n      }\n    }\n\n    // If there's only one expression just try returning the expression\n    if (nodes.length === 1) {\n      return nodes[0]\n    } else {\n      return {\n        type: COMPOUND,\n        body: nodes,\n      }\n    }\n  }\n\n  private exprI (i : number) {\n    return this.expr.charAt.call(this.expr, i)\n  }\n\n  private exprICode (i : number) {\n    return this.expr.charCodeAt.call(this.expr, i)\n  }\n\n  // Push `index` up to the next non-space character\n  private parseSpaces () {\n    let ch = this.exprICode(this.index)\n    // space or tab\n    while (ch === 32 || ch === 9 || ch === 10 || ch === 13) {\n      ch = this.exprICode(++this.index)\n    }\n  }\n\n  // The main parsing function. Much of this code is dedicated to ternary expressions\n  private parseExpression () : IExpression | null {\n    const test = this.parseBinaryExpression()\n    this.parseSpaces()\n    return test\n  }\n\n  // Search for the operation portion of the string (e.g. `+`, `===`)\n  // Start by taking the longest possible binary operations (3 characters: `===`, `!==`, `>>>`)\n  // and move down from 3 to 2 to 1 character until a matching binary operation is found\n  // then, return that binary operation\n  private parseBinaryOp () : string | null {\n    this.parseSpaces()\n    let toCheck = this.expr.substr(this.index, maxBinopLen)\n    let tcLen = toCheck.length\n    while (tcLen > 0) {\n      if (binaryOps.hasOwnProperty(toCheck)) {\n        this.index += tcLen\n        return toCheck\n      }\n      toCheck = toCheck.substr(0, --tcLen)\n    }\n    return null\n  }\n\n  // This function is responsible for gobbling an individual expression,\n  // e.g. `1`, `1+2`, `a+(b*2)-Math.sqrt(2)`\n  private parseBinaryExpression () : IExpression | null {\n    let node\n    let biop : string | null\n    let prec\n    let stack : Array<IExpression | IBiopInfo>\n    let biopInfo\n    let fbiop\n    let left\n    let right\n    let i\n\n    // First, try to get the leftmost thing\n    // Then, check to see if there's a binary operator operating on that leftmost thing\n    left = this.parseToken()\n    biop = this.parseBinaryOp()\n\n    // If there wasn't a binary operator, just return the leftmost node\n    if (!biop) {\n      return left\n    }\n\n    // Otherwise, we need to start a stack to properly place the binary operations in their\n    // precedence structure\n    biopInfo = {\n      value: biop,\n      prec: binaryPrecedence(biop),\n    }\n\n    right = this.parseToken()\n    if (!right || !left) {\n      throw new ParamError(`Expected expression after ${biop}`, this.index)\n    }\n    stack = [left, biopInfo, right]\n\n    // Properly deal with precedence using [recursive descent](http://www.engr.mun.ca/~theo/Misc/exp_parsing.htm)\n    while (true) {\n      biop = this.parseBinaryOp()\n      if (!biop) {\n        break\n      }\n\n      prec = binaryPrecedence(biop)\n\n      if (prec === 0) {\n        break\n      }\n      biopInfo = { value: biop, prec }\n\n      // Reduce: make a binary expression from the three topmost entries.\n      while (stack.length > 2) {\n        fbiop = stack[stack.length - 2]\n        if (!isIBiopInfo(fbiop) || prec > fbiop.prec) {\n          break\n        }\n        right = stack.pop()\n        stack.pop()\n        left = stack.pop()\n        if (!isIExpression(right) || !isIExpression(left)) {\n          break\n        }\n        node = createBinaryExpression(fbiop.value, left, right)\n        stack.push(node)\n      }\n\n      node = this.parseToken()\n      if (!node) {\n        throw new ParamError(`Expected expression after ${biop}`, this.index)\n      }\n      stack.push(biopInfo, node)\n    }\n\n    i = stack.length - 1\n    node = stack[i]\n    while (i > 1) {\n      fbiop = stack[i - 1]\n      left = stack[i - 2]\n      if (!isIBiopInfo(fbiop) || !isIExpression(left) || !isIExpression(node)) {\n        throw new ParamError(`Expected expression`, this.index)\n      }\n      node = createBinaryExpression(fbiop.value, left, node)\n      i -= 2\n    }\n    if (!isIExpression(node)) {\n      throw new ParamError(`Expected expression`, this.index)\n    }\n    return node\n  }\n\n  // An individual part of a binary expression:\n  // e.g. `foo.bar(baz)`, `1`, `\"abc\"`, `(a % 2)` (because it's in parenthesis)\n  private parseToken () : IUnaryExpression | IExpression | null {\n    let ch\n    let toCheck\n    let tcLen\n\n    this.parseSpaces()\n    ch = this.exprICode(this.index)\n\n    if (isDecimalDigit(ch) || ch === PERIOD_CODE) {\n      // Char code 46 is a dot `.` which can start off a numeric literal\n      return this.parseNumericLiteral()\n    } else if (ch === SQUOTE_CODE || ch === DQUOTE_CODE) {\n      // Single or double quotes\n      return this.parseStringLiteral()\n    } else if (isIdentifierStart(ch) || ch === OPAREN_CODE) { // open parenthesis\n      // `foo`, `bar.baz`\n      return this.parseVariable()\n    } else if (ch === OBRACK_CODE) {\n      return this.parseArray()\n    } else {\n      toCheck = this.expr.substr(this.index, maxUnopLen)\n      tcLen = toCheck.length\n      while (tcLen > 0) {\n        if (unaryOps.hasOwnProperty(toCheck)) {\n          this.index += tcLen\n          return {\n            type: UNARY_EXP,\n            operator: toCheck,\n            argument: this.parseToken(),\n            prefix: true,\n          }\n        }\n        toCheck = toCheck.substr(0, --tcLen)\n      }\n\n      return null\n    }\n  }\n\n  // Parse simple numeric literals: `12`, `3.4`, `.5`. Do this by using a string to\n  // keep track of everything in the numeric literal and then calling `parseFloat` on that string\n  private parseNumericLiteral () : ILiteral {\n    let rawName = ''\n    let ch\n    let chCode\n    while (isDecimalDigit(this.exprICode(this.index))) {\n      rawName += this.exprI(this.index++)\n    }\n\n    if (this.exprICode(this.index) === PERIOD_CODE) { // can start with a decimal marker\n      rawName += this.exprI(this.index++)\n\n      while (isDecimalDigit(this.exprICode(this.index))) {\n        rawName += this.exprI(this.index++)\n      }\n    }\n\n    ch = this.exprI(this.index)\n    if (ch === 'e' || ch === 'E') { // exponent marker\n      rawName += this.exprI(this.index++)\n      ch = this.exprI(this.index)\n      if (ch === '+' || ch === '-') { // exponent sign\n        rawName += this.exprI(this.index++)\n      }\n      while (isDecimalDigit(this.exprICode(this.index))) { // exponent itself\n        rawName += this.exprI(this.index++)\n      }\n      if (!isDecimalDigit(this.exprICode(this.index - 1))) {\n        throw new ParamError(`Expected exponent (${rawName}${this.exprI(this.index)})`, this.index)\n      }\n    }\n\n    chCode = this.exprICode(this.index)\n    // Check to make sure this isn't a variable name that start with a number (123abc)\n    if (isIdentifierStart(chCode)) {\n      throw new ParamError(`Variable names cannot start with a number (${rawName}${this.exprI(this.index)})`, this.index)\n    } else if (chCode === PERIOD_CODE) {\n      throw new ParamError('Unexpected period', this.index)\n    }\n\n    return {\n      type: LITERAL,\n      value: parseFloat(rawName),\n      raw: rawName,\n    }\n  }\n\n  // Parses a string literal, staring with single or double quotes with basic support for escape codes\n  // e.g. `\"hello world\"`, `'this is\\nJSEP'`\n  private parseStringLiteral () : ILiteral {\n    let str = ''\n    const quote = this.exprI(this.index++)\n    let closed = false\n    let ch\n\n    while (this.index < this.length) {\n      ch = this.exprI(this.index++)\n      if (ch === quote) {\n        closed = true\n        break\n      } else if (ch === '\\\\') {\n        // Check for all of the common escape codes\n        ch = this.exprI(this.index++)\n        switch (ch) {\n          case 'n': str += '\\n'; break\n          case 'r': str += '\\r'; break\n          case 't': str += '\\t'; break\n          case 'b': str += '\\b'; break\n          case 'f': str += '\\f'; break\n          case 'v': str += '\\x0B'; break\n          default : str += `\\\\${ch}`\n        }\n      } else {\n        str += ch\n      }\n    }\n\n    if (!closed) {\n      throw new ParamError(`Unclosed quote after \"${str}\"`, this.index)\n    }\n\n    return {\n      type: LITERAL,\n      value: str,\n      raw: quote + str + quote,\n    }\n  }\n\n  // Gobbles only identifiers\n  // e.g.: `foo`, `_value`, `$x1`\n  // Also, this function checks if that identifier is a literal:\n  // (e.g. `true`, `false`, `null`) or `this`\n  private parseIdentifier () : IIdentifier | ILiteral {\n    let ch = this.exprICode(this.index)\n    const start = this.index\n    let identifier : string\n\n    if (isIdentifierStart(ch)) {\n      this.index++\n    } else {\n      throw new ParamError(`Unexpected ${this.exprI(this.index)}`, this.index)\n    }\n\n    while (this.index < this.length) {\n      ch = this.exprICode(this.index)\n      if (isIdentifierPart(ch)) {\n        this.index++\n      } else {\n        break\n      }\n    }\n    identifier = this.expr.slice(start, this.index)\n\n    if (literals.hasOwnProperty(identifier)) {\n      return {\n        type: LITERAL,\n        value: literals[identifier],\n        raw: identifier,\n      }\n    } else {\n      return {\n        type: IDENTIFIER,\n        name: identifier,\n      }\n    }\n  }\n\n  // Gobbles a list of arguments within the context of a function call\n  // or array literal. This function also assumes that the opening character\n  // `(` or `[` has already been gobbled, and gobbles expressions and commas\n  // until the terminator character `)` or `]` is encountered.\n  // e.g. `foo(bar, baz)`, `my_func()`, or `[bar, baz]`\n  private parseArguments (termination : number) : IExpression[] {\n    let chI : number\n    const args : IExpression[] = []\n    let node\n    let closed = false\n    while (this.index < this.length) {\n      this.parseSpaces()\n      chI = this.exprICode(this.index)\n      if (chI === termination) { // done parsing\n        closed = true\n        this.index++\n        break\n      } else if (chI === COMMA_CODE) { // between expressions\n        this.index++\n      } else {\n        node = this.parseExpression()\n        if (!node || node.type === COMPOUND) {\n          throw new ParamError('Expected comma', this.index)\n        }\n        args.push(node)\n      }\n    }\n    if (!closed) {\n      throw new ParamError(`Expected ${String.fromCharCode(termination)}`, this.index)\n    }\n    return args\n  }\n\n  // Gobble a non-literal variable name. This variable name may include properties\n  // e.g. `foo`, `bar.baz`, `foo['bar'].baz`\n  // It also gobbles function calls:\n  // e.g. `Math.acos(obj.angle)`\n  private parseVariable () : IMemberExpression | IIdentifier | ILiteral | ICallExpression | IExpression | null {\n    let chI : number\n    chI = this.exprICode(this.index)\n    let node : IExpression | IIdentifier | ILiteral | IMemberExpression | ICallExpression | null = chI === OPAREN_CODE\n      ? this.parseGroup()\n      : this.parseIdentifier()\n\n    this.parseSpaces()\n    chI = this.exprICode(this.index)\n    while (chI === PERIOD_CODE || chI === OBRACK_CODE || chI === OPAREN_CODE) {\n      this.index++\n      if (chI === PERIOD_CODE) {\n        this.parseSpaces()\n        node = {\n          type: MEMBER_EXP,\n          computed: false,\n          object: node,\n          property: this.parseIdentifier(),\n        }\n      } else if (chI === OBRACK_CODE) {\n        node = {\n          type: MEMBER_EXP,\n          computed: true,\n          object: node,\n          property: this.parseExpression(),\n        }\n        this.parseSpaces()\n        chI = this.exprICode(this.index)\n        if (chI !== CBRACK_CODE) {\n          throw new ParamError('Unclosed [', this.index)\n        }\n        this.index++\n      } else if (chI === OPAREN_CODE) {\n        // A function call is being made; gobble all the arguments\n        node = {\n          type: CALL_EXP,\n          arguments: this.parseArguments(CPAREN_CODE),\n          callee: node,\n        }\n      }\n      this.parseSpaces()\n      chI = this.exprICode(this.index)\n    }\n    return node\n  }\n\n  // Responsible for parsing a group of things within parentheses `()`\n  // This function assumes that it needs to gobble the opening parenthesis\n  // and then tries to gobble everything within that parenthesis, assuming\n  // that the next thing it should see is the close parenthesis. If not,\n  // then the expression probably doesn't have a `)`\n  private parseGroup () : IExpression | null {\n    this.index++\n    const node = this.parseExpression()\n    this.parseSpaces()\n    if (this.exprICode(this.index) === CPAREN_CODE) {\n      this.index++\n      return node\n    } else {\n      throw new ParamError('Unclosed (', this.index)\n    }\n  }\n\n  // Responsible for parsing Array literals `[1, 2, 3]`\n  // This function assumes that it needs to gobble the opening bracket\n  // and then tries to gobble the expressions as arguments.\n  private parseArray () : IArrayExpression {\n    this.index++\n    return {\n      type: ARRAY_EXP,\n      elements: this.parseArguments(CBRACK_CODE),\n    }\n  }\n}\n","import ParserError from './errors/ParserError'\nimport Directive from './nodes/Directive'\nimport IfCondtionDirective from './nodes/directives/IfCondtion'\nimport Include from './nodes/directives/Include'\nimport List from './nodes/directives/List'\nimport UnknownDirective from './nodes/directives/UnknownDirective'\nimport Interpolation from './nodes/Interpolation'\nimport Macro from './nodes/Macro'\nimport Text from './nodes/Text'\nimport { ENodeType, EType, IParams } from './Types'\n\nimport { BaseNode } from './nodes/BaseNode'\nimport { ParamsParser } from './params/ParamsParser'\nimport { Token } from './tokens/Token'\n\nfunction newDirective (token : Token) : Directive {\n  switch (token.type) {\n    case EType.if:\n    case EType.elseif:\n      return new IfCondtionDirective(token.type, parseParams(token), token.startPos, token.endPos)\n    case EType.list:\n      return new List(token.type, parseParams(token), token.startPos, token.endPos)\n    case EType.include:\n      return new Include(token.type, parseParams(token), token.startPos, token.endPos)\n    // TODO: add more types\n  }\n\n  return new UnknownDirective(token.type, parseParams(token), token.startPos, token.endPos)\n}\n\nfunction parseParams (token : Token) : IParams {\n  const parser = new ParamsParser()\n  const params : IParams = []\n  for (const param of token.params) {\n    console.log(`parseParams: \\`${param}\\``)\n    params.push(parser.parse(param))\n  }\n  return params\n}\n\nfunction newNode (token : Token) : BaseNode {\n  switch (token.nodeType) {\n    case ENodeType.Directive:\n      return newDirective(token)\n    case ENodeType.Macro:\n      return new Macro(token.tag, parseParams(token), token.startPos, token.endPos)\n    case ENodeType.Interpolation:\n      return new Interpolation(token.startPos, token.endPos, parseParams(token))\n    case ENodeType.Text:\n      return new Text(token.text, token.startPos, token.endPos)\n  }\n  throw new ParserError('Unknown symbol')\n}\n\nexport function createNode (token : Token) : BaseNode {\n  const node : BaseNode = newNode(token)\n  if (node.$config.disallowParams && token.params.length > 0) {\n    throw new ParserError(`Params are not allowed in \\`${node.$eType}\\``)\n  }\n\n  return node\n}\n","import { ENodeType, EType } from '../Types'\nimport { BaseNode } from './BaseNode'\n\nexport default class Program extends BaseNode {\n  public children : BaseNode[]\n\n  constructor (start : number, end : number) {\n    super(ENodeType.Program, start, end, EType.Program)\n    this.children = []\n  }\n\n  public addChild (node : BaseNode) : BaseNode {\n    this.children.push(node)\n    return this\n  }\n}\n","import { ENodeType } from './Types'\n\nexport interface ISymbol {\n  startToken : string\n  endToken : string\n  type : ENodeType\n  end : boolean\n}\n\nexport const symbols : ISymbol[] = [\n  { startToken: '</#', endToken: '>', type: ENodeType.Directive, end: true },\n  { startToken: '<#', endToken: '>', type: ENodeType.Directive, end: false },\n  { startToken: '</@', endToken: '>', type: ENodeType.Macro, end: true },\n  { startToken: '<@', endToken: '>', type: ENodeType.Macro, end: false },\n  // tslint:disable-next-line:no-invalid-template-strings\n  { startToken: '${', endToken: '}', type: ENodeType.Interpolation, end: false },\n]\n\nexport const whitespaces : string[] = [\n  ' ',\n  '\\t',\n  '\\n',\n  '\\r',\n]\n","import { ENodeType, EType } from '../Types'\n\nexport class Token {\n  public startPos : number\n  public endPos : number\n  public type : EType\n  public nodeType : ENodeType\n  public params : string[]\n  public tag : string\n  public isClose : boolean\n  public text : string\n\n  constructor (symbol : ENodeType, startPos : number, endPos : number, type : EType = EType.Text, params : string[] = [], tag : string = '', isClose : boolean = false, text : string = '') {\n    this.nodeType = symbol\n    this.startPos = startPos\n    this.endPos = endPos\n    this.type = type\n    this.params = params\n    this.tag = tag\n    this.isClose = isClose\n    this.text = text\n  }\n}\n","import ParserError from './errors/ParserError'\nimport { ISymbol, symbols, whitespaces } from './Symbols'\nimport { Token } from './tokens/Token'\nimport { ENodeType, EType } from './Types'\n\nexport default class Tokenizer {\n  private template : string = ''\n  private tokens : Token[] = []\n  private cursorPos : number = 0\n\n  public parse (template : string) : Token[] {\n    this.template = template\n    while (this.cursorPos >= 0 && this.cursorPos < this.template.length) {\n      const token = this.parseToken()\n      if (!token) {\n        this.tokens.push(this.makeToken(ENodeType.Text, this.cursorPos, this.template.length))\n        break\n      }\n    }\n    return this.tokens\n  }\n\n  private makeToken (symbol : ENodeType, startPos : number, endPos : number, type : EType = EType.Text, params : string[] = [], tag : string = '', isClose : boolean = false) : Token {\n    // Get text => this.template.substring(startPos, endPos),\n    return new Token(symbol, startPos, endPos, type, params, tag, isClose, type !== EType.Text ? '' : this.template.substring(startPos, endPos))\n  }\n\n  private getNextPos (items : string[]) : number {\n    let pos = -1\n    for (const item of items) {\n      const n = this.template.indexOf(item, this.cursorPos)\n      if (n >= 0 && (pos === -1 || n < pos)) {\n        pos = n\n      }\n    }\n    return pos\n  }\n\n  private parseTag (endTag : string) : string {\n    const pos = this.getNextPos([\n      ...whitespaces,\n      endTag,\n    ])\n    if (pos < 0) {\n      throw new ParserError('Missing closing tag') // TODO: add more info like location\n    }\n    return this.template.substring(this.cursorPos, pos)\n  }\n\n  private parseToken () : boolean {\n    let symbol : ISymbol | null = null\n    let startPos : number = 0\n    for (const item of symbols) {\n      const n = this.template.indexOf(item.startToken, this.cursorPos)\n      if (n >= 0 && (!symbol || n < startPos)) {\n        symbol = item,\n        startPos = n\n      }\n    }\n\n    if (!symbol) {\n      return false\n    }\n\n    if (startPos - 1 > this.cursorPos) {\n      this.tokens.push(this.makeToken(ENodeType.Text, this.cursorPos, startPos - 1))\n    }\n    this.cursorPos = startPos\n\n    this.cursorPos += symbol.startToken.length\n\n    let node : Token | null = null\n\n    switch (symbol.type) {\n      case ENodeType.Directive: // <#foo>/</#foo>\n        node = this.parseDirective(symbol, startPos, symbol.end)\n        break\n      case ENodeType.Macro: // <@foo>\n        node = this.parseMacro(symbol, startPos, symbol.end)\n        break\n      case ENodeType.Interpolation: // ${ foo?string }\n        node = this.parseInterpolation(symbol, startPos)\n        break\n      default:\n        break\n    }\n\n    if (node) {\n      this.tokens.push(node)\n    }\n\n    ++this.cursorPos\n    return true\n  }\n\n  private parseInterpolation (symbol : ISymbol, startPos : number) : Token {\n    const params : string[] = this.parseParams(symbol.endToken)\n    const node = this.makeToken(ENodeType.Interpolation, startPos, this.cursorPos, EType.Interpolation, params)\n    return node\n  }\n\n  private parseMacro (symbol : ISymbol, startPos : number, isClose : boolean = false) : Token {\n    const typeString = this.parseTag(symbol.endToken)\n    this.cursorPos += typeString.length\n\n    const params : string[] = typeString.endsWith(symbol.endToken) ? [] : this.parseParams(symbol.endToken)\n\n    const node = this.makeToken(ENodeType.Macro, startPos, this.cursorPos, EType.MacroCall, params, typeString, isClose)\n\n    return node\n  }\n\n  private parseDirective (symbol : ISymbol, startPos : number, isClose : boolean = false) : Token {\n    const typeString = this.parseTag(symbol.endToken)\n    if (!(typeString in EType)) {\n      throw new ParserError(`Unsupported directive ${typeString}`) // TODO: add more info like location\n    }\n    this.cursorPos += typeString.length\n\n    const params : string[] = typeString.endsWith(symbol.endToken) ? [] : this.parseParams(symbol.endToken)\n\n    const node = this.makeToken(ENodeType.Directive, startPos, this.cursorPos, typeString as EType, params, '', isClose)\n    // TODO; read params\n\n    return node\n  }\n\n  private isWhitespace (char : string) : boolean {\n    return char === ' ' || char === '\\t' || char === '\\r' || char === '\\n'\n  }\n\n  // When you want to test if x > 0 or x >= 0, writing <#if x > 0> and <#if x >= 0> is WRONG,\n  // as the first > will close the #if tag. To work that around, write <#if x gt 0> or <#if gte 0>.\n  // Also note that if the comparison occurs inside parentheses, you will have no such problem,\n  // like <#if foo.bar(x > 0)> works as expected.\n  private parseParams (engTag : string) : string[] {\n    const text = this.template.substring(this.cursorPos)\n    const params : string[] = []\n    let paramText : string = ''\n    let paramPos : number = this.cursorPos\n    let bracketLevel = 0\n    let inString = false\n\n    for (const char of text) {\n      if (char === '\"') {\n        inString = !inString\n      }\n\n      if (!inString) {\n        if (char === '(') {\n          ++bracketLevel\n        } else if (char === ')') {\n          --bracketLevel\n        }\n      }\n\n      if (bracketLevel < 0) {\n        throw new ParserError(`bracketLevel < 0`) // TODO: add more info like location\n      }\n\n      if (bracketLevel === 0 && !inString) {\n        if (char === engTag) {\n          if (paramText !== '') {\n            params.push(paramText)\n            paramText = ''\n          }\n          this.cursorPos = paramPos + engTag.length\n          return params\n        } else if (this.isWhitespace(char)) {\n          if (paramText !== '') {\n            params.push(paramText)\n            paramText = ''\n          }\n          ++paramPos\n          this.cursorPos = paramPos\n        } else {\n          paramText += char\n          ++paramPos\n        }\n      } else {\n        paramText += char\n        ++paramPos\n      }\n    }\n    throw new ParserError(`Unclosed directive or macro`) // TODO: add more info like location\n  }\n}\n","import NodeError from './errors/NodeError'\n\nimport { createNode } from './NodeHelper'\nimport { EType } from './Types'\n\nimport { BaseNode } from './nodes/BaseNode'\nimport Program from './nodes/Program'\n\nimport Tokenizer from './Tokenizer'\nimport { Token } from './tokens/Token'\n\nexport class Parser {\n  public template : string = ''\n  private AST : Program\n  private tokens : Token[]\n\n  constructor () {\n    this.template = ''\n    this.tokens = []\n  }\n\n  public parse (template : string) : Program {\n    this.template = template\n    this.AST = new Program(0, template.length)\n    this.build()\n    return this.deepClone(this.AST)\n  }\n\n  private deepClone (text : Program) {\n    const cache : BaseNode[] = []\n    const json = JSON.stringify(text, (key, value) => {\n      if (key.startsWith('$')) {\n        return\n      }\n      if (typeof value === 'object' && value !== null) {\n        if (cache.indexOf(value) !== -1) {\n          // Circular reference found, discard key\n          return\n        }\n        // Store value in our collection\n        cache.push(value)\n      }\n      return value\n    }, 2)\n    return JSON.parse(json)\n  }\n\n  private build () {\n    const stack : BaseNode[] = []\n    let parent : BaseNode = this.AST\n    let node : BaseNode | null = null\n\n    const tokenizer = new Tokenizer()\n    this.tokens = tokenizer.parse(this.template)\n\n    for (const token of this.tokens) {\n      node = createNode(token)\n\n      this.canContain(node, parent)\n\n      if (node.$config.isSelfClosing) {\n        if (token.isClose) {\n          throw new NodeError(`Unexpected close tag`, node)\n        }\n        parent = parent.addChild(node)\n      } else if (token.isClose) {\n        let parentNode : BaseNode | undefined = parent\n        while (parentNode) {\n          if (parentNode.$nodeType === token.nodeType) {\n            parentNode = stack.pop()\n            break\n          }\n          if (!parentNode.$config.isSelfClosing) {\n            throw new NodeError(`Missing close tag`, parentNode)\n          }\n          parentNode = stack.pop()\n        }\n\n        if (!parentNode) {\n          throw new NodeError(`Closing tag is not alowed`, node)\n        }\n        parent = parentNode\n\n      } else {\n        parent = parent.addChild(node)\n        stack.push(parent)\n        parent = node\n      }\n    }\n\n    if (stack.length > 0) {\n      throw new NodeError(`Unclosed tag`, parent)\n    }\n  }\n\n  private canContain (node : BaseNode, parent : BaseNode) {\n    if (!node.canAddTo(parent)) {\n      throw new NodeError(`${this.debugNode(node.$eType)} require one of parents ${this.debugNode(node.$config.onlyIn)} but found in ${this.debugNode(parent.$eType)}`, node)\n    }\n  }\n\n  private debugNode (data? : string | EType[]) {\n    if (!data) {\n      return '[?]'\n    }\n    if (data instanceof Array) {\n      return `[\\`${data.map((it) => `${it}`).join(', ')}\\`]`\n    }\n    return `\\`${data}\\``\n  }\n}\n"],"names":["IfCondtionDirective"],"mappings":"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"}
